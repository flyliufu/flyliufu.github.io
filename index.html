<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="My way of learning">
<meta property="og:url" content="https://flyliufu.github.io/index.html">
<meta property="og:site_name" content="My way of learning">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My way of learning">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://flyliufu.github.io/">





  <title> My way of learning </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My way of learning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://flyliufu.github.io/2019/12/19/普林斯顿2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fu Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/9735870?v=3&u=33ed681a589c432a123bbdc242b25d56a1a0ac7b&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My way of learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/12/19/普林斯顿2/" itemprop="url">
                  普林斯顿2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-19T16:03:53+08:00">
                2019-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/原创/" itemprop="url" rel="index">
                    <span itemprop="name">原创</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/12/19/普林斯顿2/" class="leancloud_visitors" data-flag-title="普林斯顿2">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h1 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://flyliufu.github.io/2019/12/19/普林斯顿1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fu Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/9735870?v=3&u=33ed681a589c432a123bbdc242b25d56a1a0ac7b&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My way of learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/12/19/普林斯顿1/" itemprop="url">
                  普林斯顿1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-19T09:19:44+08:00">
                2019-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/原创/" itemprop="url" rel="index">
                    <span itemprop="name">原创</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/12/19/普林斯顿1/" class="leancloud_visitors" data-flag-title="普林斯顿1">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h1 id="三角恒等式"><a href="#三角恒等式" class="headerlink" title="三角恒等式"></a>三角恒等式</h1><pre><code>正弦：(sin) sine
余弦：(cos) cosine
正切：(tan) tangent
余切：(cot) cotangent
正割：(sec) secant
余割：(csc) cosecant
</code></pre><ul>
<li><p>$$tan(x)=\frac {sin(x)} {cos(x)}$$</p>
</li>
<li><p>$$cot(x)=\frac {cos(x)} {sin(x)}$$</p>
</li>
<li><p>$$sin^2(x)+cos^2(x) = 1$$</p>
</li>
<li><p>$$1+tan^2(x)=sec^2(x)$$</p>
</li>
<li><p>$$cot^2(x)+1=csc^2(x)$$</p>
</li>
<li><p>$$sin(A+B) =  sin(A)cos(B) + cos(A)sin(B)$$</p>
</li>
<li>$$cos(A+B) =  cos(A)cos(B) - sin(A)sin(B)$$</li>
<li>$$sin(A-B)=sin(A)cos(B)-cos(A)sin(B)$$</li>
<li>$$cos(A-B)=cos(A)cos(B) + sin(A)sin(B)$$</li>
</ul>
<p>令 A = B = x 得：</p>
<ul>
<li>$$sin(2x) = 2sin(x)cos(x)$$</li>
<li>$$cos(2x) = 2cos^2(x) - 1 = 1 - 2sin^2(x)$$</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://flyliufu.github.io/2019/09/15/JVM-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fu Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/9735870?v=3&u=33ed681a589c432a123bbdc242b25d56a1a0ac7b&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My way of learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/09/15/JVM-4/" itemprop="url">
                  JVM-4：HotSpot 的算法实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-15T21:34:27+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/原创/" itemprop="url" rel="index">
                    <span itemprop="name">原创</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/09/15/JVM-4/" class="leancloud_visitors" data-flag-title="JVM-4：HotSpot 的算法实现">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h1><h2 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h2><ul>
<li>从可达性分析中从 GC Roots 节点找引用链为例，可作为 GC Roots 的节点主要在全局性的引用与执行上下文中，现在很多应用仅方法区就有数百兆可如果要检查这里面的引用必然消耗很多时间</li>
<li>可达性分析对执行时间的敏感还体现在 GC 停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行，一致性是指在分析期间整个系统就像被冻结在某个时间点，不可以出现分析过程中对象引用关系不断变化的情况，如果不满足这个，分析结果无法保证。 这导致 GC 进行时必须停顿所有 Java 执行线程（SUN 称作为 Stop The World）</li>
<li>目前主流的 java 虚拟机使用的都是准确式 GC 所以当执行系统停顿下来后，并不需要一个不漏的检查上下文和全局的引用位置，虚拟机可以直接得知哪些地方存放着引用，在 HotSpot 中使用一组称为 <code>OopMap</code> 的数据结构来达到此目的，在类加载完成的时候 hotspot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中也会在特定的位置记录下栈和寄存器中哪些位置是引用</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://flyliufu.github.io/2019/08/31/JVM-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fu Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/9735870?v=3&u=33ed681a589c432a123bbdc242b25d56a1a0ac7b&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My way of learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/08/31/JVM-3/" itemprop="url">
                  JVM-3：垃圾收集器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-31T11:03:48+08:00">
                2019-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/原创/" itemprop="url" rel="index">
                    <span itemprop="name">原创</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/31/JVM-3/" class="leancloud_visitors" data-flag-title="JVM-3：垃圾收集器">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先说明 GC（垃圾收集）并不是 java 的伴生产物，1960年 MIT 的 <code>Lisp</code> 是第一门真正使用动态内存分配和垃圾收集技术的语言。</p>
<ul>
<li>垃圾收集需要做的事情：</li>
</ul>
<ol>
<li>那些内存需要回收</li>
<li>什么时候回收</li>
<li>怎么回收</li>
</ol>
<p>java 内存运行时区域的各个部分包括程序计数器、本地方法栈、虚拟机栈这三个区域随线程而生死（在运行期 JIT 会进行优化，但在此暂认为是编译期可知的），这几个区域的回收是有确定性，在方法或者线程结束后内存就自然回收了。</p>
<p>而 java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间是才能知道会创建那些对象，本章后续中讨论的“内存” 也是指这部分。</p>
<h2 id="如何判断一个对象是否还存活"><a href="#如何判断一个对象是否还存活" class="headerlink" title="如何判断一个对象是否还存活"></a>如何判断一个对象是否还存活</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象添加一个引用计数器，每当有一个地方引用时，计数器值加1；当引用失效时，计数器值减1，任何时刻计数器为0的对象就是不可再被使用的。</p>
<ul>
<li>引用计数算法效率高，实现简单，大部分情况下是不错算法也有著名的应用案例。</li>
</ul>
<p><strong>缺点</strong>：无法解决循环引用问题，造成内存无法回收（HotSpot 中使用的不是该算法）。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul>
<li><p>这种算法思路就是通过一系列的称为 <code>GC Roots</code> 的对象作为起始点，从这些节点向下开始搜索，搜索走过的路径称为引用链（Reference Chain），当一个对象到 <code>GC Roots</code> 没有任何引用链相连时，则证明此对象是不可用的，判定为可回收对象</p>
</li>
<li><p><code>GC Roots</code> 包括以下几种：</p>
</li>
</ul>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 <code>JNI</code> （即一般说的 Native 方法）引用的对象</li>
</ol>
<h3 id="java-中的引用类型"><a href="#java-中的引用类型" class="headerlink" title="java 中的引用类型"></a>java 中的引用类型</h3><p>在 JDK 1.2 以前 java 中的引用定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹也很狭隘，无法描述这样一类对象：在内存空间足够的时候保留；如果内存进行 GC 后还是很紧张刚可以抛弃这些对象</p>
<p>在 JDK 1.2 以后 java 对引用的概念进行了扩充，将引用分为：</p>
<ol>
<li>强引用 <code>Strong Refrence</code></li>
<li>软引用 <code>Soft Refrence</code></li>
<li>弱引用 <code>Weak Refrence</code></li>
<li>虚引用 <code>Phantom Refrence</code></li>
</ol>
<p>这四种引用强度依次逐渐减弱</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用就是指在程序代码之路普遍存在的，类似 <code>Object obj = new Object();</code> 这类的引用。只要引用还在，垃圾收集器永远不会回收被引用的对象。</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用用来描述非必需的对象，对于软引用关联的对象，在系统次要发生内存溢出异常之前，将会把这部分对象列进回收范围之中进行二次回收。如果这次回收还没有足够内存才会抛出内存溢出异常。</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>也是用来描述非必需对象，但比软引用强度还弱一些，被弱引用关联的对象只能活到下一次垃圾回收发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其我现在时间构成影响，也无法通过虚引用来取得一个对象的实例，唯一目的就是能在这个对象被垃圾回收时收到一个通知</p>
<h3 id="对象生或死"><a href="#对象生或死" class="headerlink" title="对象生或死"></a>对象生或死</h3><p>即使在可达性分析算法中不可达的对象也不一定“非死不可”，这时候他们处于“缓刑”阶段，要真正宣告一个对象的死亡，至少要经历两次标记过程：</p>
<ol>
<li>如果对象在进行可达性分析后发现没有 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖该方法，或者该方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</li>
<li>如果这个对象判官为有必要执行 finalize() 方法，那么这个对象将会被放置在一个叫作 <code>F-Queue</code> 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 <code>Finalizer</code> 线程去执行它。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等它运行结束，这样做的原因是如果一个对象在 finalize 方法中执行缓慢，或者死循环了，将很有可能会导致 F-Queue 队列中的其他对象永久处于等待，甚至内存回收系统崩溃。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><em>finalize 方法的运行分工合作高昂，不确定性大，无法保证各个对你的调用顺序。该方法可以做的所有工作使用其他方式都可以很好的解决，所以不要使用该方法。</em></p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>很多人认为方法区（或者 HotSpot虚拟机中的永久代）是没有垃圾收集的，java 虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集可以回收 70% - 95% 的空间，而永久代的垃圾收集效率远低于此。</p>
<p>永久代中的垃圾收集分为两部分内容：废弃的常量和无用的类。</p>
<ol>
<li>回收废弃常量与回收 java 堆中的对象非常类似。以常量池中字面量的回收为例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假如一个字符串 &quot;abc&quot; 已经进入了常量池中，但是当前系统没有任何一个 String 对象是叫做 &quot;abc&quot; 的，换句话说，就是没有任何 String 对象引用常量池中的 &quot;abc&quot; 常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个 &quot;abc&quot; 常量就会被系统清理出常量池</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<ol start="2">
<li>回收无用的类条件比较苛刻：<ol>
<li>该类所有实例都已经被回收，java 堆中不存在该类的任何实例</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法<br>虚拟机对上面满足 3 种情况的无用类进行回收，这里说的仅仅是”可以“，而并不是和对象一样，不使用了就必然会回收。是否进行回收，HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制。</li>
</ol>
</li>
</ol>
<p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGI 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，保证永久代不会溢出。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>算法分为：”标记“和”清除“两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法的不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记主队之后会产生大量不连续的内存碎片，空间碎片太多可能导致以后在程序运行过程中需要分配较大对象时，无法找到足够连续内存而不得不提前触发另 次垃圾收集动作。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题,一种称为”复制“（Copying） 的算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块内存用完，将活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。内存分配时不用考虑碎片问题，实现简单，运行高效。该算法的不足是将内存缩小为原来的一半。</p>
<p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%在上海的极端情况，所以在老年代一般不能直接选用这种算法</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记过程仍然与”标记-清除“算法一样，但后面不是对可回收对象进行清理，而是让所有存活对象向一端移动然后直接清理掉边界以外的内存。</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集采用的都是”分代收集“（Generational Collection） 算法，根据对象在上海周期的不同将内存划分为几块，一般是把 java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。在新生代中每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需付出少量存活对象成本就可以完成收集；而在老年代中存活率比较高、没有额外空间对它进行分配担保就只能使用”标记-清理“或者”标记-整理“算法来进行回收。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://flyliufu.github.io/2019/08/24/JVM-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fu Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/9735870?v=3&u=33ed681a589c432a123bbdc242b25d56a1a0ac7b&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My way of learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/08/24/JVM-2/" itemprop="url">
                  JVM-2：了解 jvm 中 java 对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-24T07:34:59+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/原创/" itemprop="url" rel="index">
                    <span itemprop="name">原创</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/24/JVM-2/" class="leancloud_visitors" data-flag-title="JVM-2：了解 jvm 中 java 对象">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="了解-jvm-中-java-对象"><a href="#了解-jvm-中-java-对象" class="headerlink" title="了解 jvm 中 java 对象"></a>了解 jvm 中 java 对象</h1><h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p>  只讨论普通对象，不包括数组、<code>Class</code> 对象。</p>
<ol>
<li>虚拟机遇到 <code>new</code> 指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化过。如果没有需要执行相应操作（Chapter 7）</li>
<li>接下来虚拟机为对象分配内存，对象所需大小在类加载完成即可明确。内存分配分为两种方式：<ol>
<li>指针碰撞：如果 java 堆内存是绝对规整的，使用的内存在一边，未使用在另一边，中间放着一个指针作为分界点指示器，分配内存的动作就是把指针向空闲方向移动对象大小的距离</li>
<li>空闲列表：如果 java 堆内存不是规整的，虚拟机就需要维护一个列表记录那些内存是可用的分配时候找出一块足够大的内存划分给对象。</li>
</ol>
</li>
</ol>
<p>选择哪种分配方式要看 java 堆是否规整，java 堆是否规整又和 GC 收集器是否带压缩整理功能决定。</p>
<p>创建对象在虚拟机中是非常频繁的，即使修改一个指针指向位置在并发环境下也并不是线程安全，解决这个问题有两种方案：</p>
<pre><code>1. 对分配内存空间的动作进行同步处理
2. 把内存分配动作按线程划分在不同空间中进行，即每个线程在 java 堆中预先分配一小块内存称为本地线程分配缓冲（Thread Local Allocation Buffer , TLAB）线程内存分配在自己的 TLAB 上，只有当 TLAB 用完并且分配新的时候，才需同步锁定。是否使用 TLAB 用 `-XX:+/-UseTLAB` 参数
</code></pre><ol start="3">
<li>内存分配完成后虚拟机要将分配到的内存初始化为零值（不包括对象头），如果用 TLAB 这一操作可提前到 TLAB 分配时进行，这步操作保证了对象的实例字段在不赋值的时候就可以使用，程序访问到的是属性对应的零值。</li>
<li>虚机机需要对对象做必要的设置，例如对象是那个类的实例、如何找到类的元数据信息、对象的哈希码、对你的 GC 分代年龄等信息。</li>
<li>以上操作完成后从虚拟机的角度来说已经完成一个新对象已经产生，但从 java 角度来说才刚开始 —— <code>&lt;init&gt;</code> 方法还没执行，一般情况执行完 <code>new</code> 指令后会接着执行 <code>&lt;init&gt;</code> 把对象按程序员的意愿进行初始化，至此对象才完全产生出来。</li>
</ol>
<h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><ul>
<li>在 HotSpot 虚拟机中对象内存的布局分为3块区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）</li>
<li>HotSpot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、 偏向时间戳等<ul>
<li>对象的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，</li>
<li>如果对象是一个 java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通的 java 对象的元数据信息确定 java 对象的大小，但从数组的元数据信息无法确定数组的大小</li>
</ul>
</li>
<li>实例数据部分是对你真正存储的的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论在父类继承还是子类定义全部需要记录下来。同同宽度的字段总是分配到一起，在这前提下父类中定义的变量会出现在子类之前，如果 CompatField 参数值为 true （默认为 true） 子类中较窄的变量也可能插入到父类变量的空隙之路</li>
<li>对象填充不是必然存在的，也没特殊含义，HotSpot 虚拟机中要求对象大小必须是8的整数倍，对象头是8的整数倍，当实例数据部分没有对齐时需要通过对齐填充来补全。<h3 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h3>java 程序需要通过栈上的 reference 数据来操作堆上的具体对象， JVM 虚拟机规范中只支付宝了一个指向对象的引用，并没有定义这个引用该通过何种方式去定位，所以具体实现也取决于虚拟机实现。</li>
</ul>
<p>目前主流的访问方式有两种：</p>
<ol>
<li><p>句柄访问</p>
<p> java 堆中会划分出一块内存来作为句柄池，reference 中存储的是对象的句柄地址而句柄中包含了对象的实例数据与类型数据各自的具体地址信息。</p>
</li>
</ol>
<p><img src="/images/JVM/reference_handle.jpg" alt></p>
<ul>
<li>使用该方式好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（GC 时候移动对象是非常普遍的行为）时只会改变句柄中实例数据的指针， reference 本身不需要修改</li>
</ul>
<ol start="2">
<li><p>直接指针访问</p>
<p> 直接指针会指向堆中实例数据，实例数据中会指向其实际类型数据</p>
</li>
</ol>
<p><img src="/images/JVM/reference_direct.jpg" alt></p>
<ul>
<li>使用本方式的最大好处就是速度更快了，节省了一次指针定位的时间开销，在 HotSpot 中使用的是本方式访问对象 </li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://flyliufu.github.io/2019/08/13/JVM-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fu Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/9735870?v=3&u=33ed681a589c432a123bbdc242b25d56a1a0ac7b&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My way of learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/08/13/JVM-1/" itemprop="url">
                  JVM-1：内存区域与内存溢出
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-13T09:42:27+08:00">
                2019-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/原创/" itemprop="url" rel="index">
                    <span itemprop="name">原创</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/13/JVM-1/" class="leancloud_visitors" data-flag-title="JVM-1：内存区域与内存溢出">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="内存区域与内存溢出"><a href="#内存区域与内存溢出" class="headerlink" title="内存区域与内存溢出"></a>内存区域与内存溢出</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><ul>
<li>java 虚拟机在执行 java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3></li>
<li>一块较小的内存空间，可以看作当前线程所执行的字节码行号指示器</li>
<li>改变计数器的值选取下一条需要执行字节码指令。（分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个计数器）</li>
<li>一个确定时刻一个处理器（多核处理器是一个内核）只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，所以每个线程都需要有一个独立的程序计数器我们称这类内存区域第<code>线程私有</code>内存</li>
<li>当线程正在执行 java 方法时候记数器记录的是正在执行的虚拟机字节码指令地址，如果是 Native 方法计数器值为空（Undefined）</li>
<li>此区域是唯一一个在 java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3></li>
<li>线程私有，生命周期与线程相同</li>
<li>虚拟机栈描述的是 java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>
<li>局部变量表存放了8种基本数据类型、对象引用（不是对象，reference 类型）、returnAddress 类型（指向一条字节码指令的地址）。</li>
<li><code>long</code>、<code>double</code> 占用了两个局部空间其余占一个。</li>
<li>局部变量表所需内存空间在编译期间完成分配，运行方法的时候所需多大空间固定且不变。</li>
<li>该区域有两种异常状况：如果线程请求栈的深度大于虚拟机允许的深度抛出 StackOverflowError；如果虚拟机栈可以动态扩展，当扩展时无法申请足够的内存抛出 OutOfMemoryError 异常<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3></li>
<li>和虚拟机栈发挥的作用相似，该区域为本地方法服务。</li>
<li>在 HotSpot 虚拟机中该区域和虚拟机栈合并在一起</li>
<li>会抛出 StackOverflowError OutOfMemoryError<h3 id="java-堆"><a href="#java-堆" class="headerlink" title="java 堆"></a>java 堆</h3></li>
<li>java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建</li>
<li>java 堆从内存回收的角度来看由于采用分代回收算法所以可以分为：新生代、老年代</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li>方法区与 java 堆一样是各个线程共享的一块区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
<li>此区域并不是永久代，只是因为 HotSpot 虚拟机的设计团队把 GC 分代收集的算法扩展至方法区，或者说用永久代实现方法区而已。使用永久代来实现方法区并不是一个好主意，因为这样更容易遇到内存溢出的问题。HotSpot 目前正在逐步放弃永久代用 Native Memory 来实现方法区。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://flyliufu.github.io/2018/06/07/初识 R/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fu Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/9735870?v=3&u=33ed681a589c432a123bbdc242b25d56a1a0ac7b&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My way of learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/07/初识 R/" itemprop="url">
                  初识 R
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T13:50:42+08:00">
                2018-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/原创/" itemprop="url" rel="index">
                    <span itemprop="name">原创</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/06/07/初识 R/" class="leancloud_visitors" data-flag-title="初识 R">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="初识-R"><a href="#初识-R" class="headerlink" title="初识 R"></a>初识 R</h1><p>​    R 语言是什么维基百科对<a href="https://zh.wikipedia.org/wiki/R%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">R 语言</a> 的描述总结就是一个很牛逼的绘图不仅仅限于绘图的语言。至于我为什么要学习这个语言，现在我做安卓开发，但一直和代码打交道受到中国 IT 界环境影响，即使我想一直写代码下去，可能也没有地方让我去永远写下去。为了自己以后有饭吃需要学习些东西，经人指点可以转而做数据分析师，虽然道阻且长但还要砥砺前行，在此写下此博文算是立个 flag，文章写的不好多多交流！</p>
<h2 id="一-R-数据结构"><a href="#一-R-数据结构" class="headerlink" title="一.    R 数据结构"></a>一.    R 数据结构</h2><p>​    R 语言中数据结构有 标量、向量、矩阵、数组、数据框和列表。 这些名词听起来和很多其他语言都有共通的名称，但就我懂的 <code>Java</code> 语言来说还是有些区别下面一一来学习</p>
<h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><p>​    标量很像 <code>Java</code> 中的变量，如下所示可以定义一个标量</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- <span class="number">3</span></span><br><span class="line">g &lt;- <span class="string">"US"</span></span><br><span class="line">h &lt;- <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure>
<p>说明几点</p>
<ol>
<li>R 中赋值操作符是<code>&lt;-</code> 当然可以用<code>=</code> 但不提倡</li>
<li>R 中没有明确非要以<code>;</code> 结束（至少我目前没发现）</li>
<li>R 中是大小写敏感的语言</li>
</ol>
<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>​    向量是用来存放数值、字符型或是逻辑型数据的一维数组，用函数<code>c()</code> 来创建。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">b &lt;- c(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"D"</span>)</span><br><span class="line">c &lt;- c(<span class="literal">TRUE</span>,<span class="literal">FALSE</span>,<span class="literal">TRUE</span>,<span class="literal">FALSE</span>,<span class="literal">TRUE</span>,<span class="literal">FALSE</span>,<span class="literal">TRUE</span>,<span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<p>在 R 中逻辑值真假为<code>TRUE</code> <code>FALSE</code> 全大写</p>
<p>​    访问向量中的数据我总结的是有两种方式位置法和区间法</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问 a 的2，4 的元素</span></span><br><span class="line">a[c(<span class="number">2</span>,<span class="number">4</span>)] <span class="comment"># 输出 2 4 </span></span><br><span class="line"><span class="comment"># 访问 b 的1 到 3 的元素</span></span><br><span class="line">b[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 输出 a b c</span></span><br></pre></td></tr></table></figure>
<p>在 R 中访问的并不是下标从0开始，而是从1开始的位置，区间比较好理解就是从1 到 3 的数据</p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>​    说到矩阵第一个想到线性代数，没错就是一样的东西，在<code>Java</code> 中更像是个二维数组，同样可以创建上面三种类型的矩阵，使用函数<code>matrix()</code> 创建</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># outMatrix &lt;- matrix(data = dataVec, nrow = nrow, ncol = ncol, byrow = byrow)</span></span><br><span class="line">y &lt;- matrix(<span class="number">1</span>:<span class="number">20</span>,nrow = <span class="number">5</span>, ncol = <span class="number">4</span>)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<p><code>data</code> ：创建矩阵数据</p>
<p><code>nrow</code> ：行数</p>
<p><code>ncol</code> ：列数</p>
<p><code>byrow</code> ：按行还是按列填充，<code>TRUE</code> 或 <code>FALSE</code> 默认按列</p>
<p>相关参数很多不能一一列明 可以使用在线帮助文档<code>help(matrix)</code> 获取帮助</p>
<p>​    访问矩阵的数据</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个两行五列的矩阵如下</span></span><br><span class="line">x &lt;- matrix(<span class="number">1</span>:<span class="number">10</span>, nrow = <span class="number">2</span>)</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment">## 输出第二行</span></span><br><span class="line">print(x[<span class="number">2</span>,])</span><br><span class="line"><span class="comment">## 输出第二列</span></span><br><span class="line">print(x[,<span class="number">2</span>])</span><br><span class="line"><span class="comment">## 输出1行四列</span></span><br><span class="line">print(x[<span class="number">1</span>,<span class="number">4</span>])</span><br><span class="line"><span class="comment">## 范围输出</span></span><br><span class="line">print(x[<span class="number">1</span>,c(<span class="number">4</span>,<span class="number">5</span>)])</span><br></pre></td></tr></table></figure>
<p>非常直观易懂，但还是希望多打代码去练习，这样才能加深印象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://flyliufu.github.io/2018/02/07/二叉树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fu Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/9735870?v=3&u=33ed681a589c432a123bbdc242b25d56a1a0ac7b&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My way of learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/07/二叉树/" itemprop="url">
                  二叉树之二叉查找树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T13:50:42+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/02/07/二叉树/" class="leancloud_visitors" data-flag-title="二叉树之二叉查找树">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树 Binary Search Tree"></a>二叉查找树 Binary Search Tree</h1><p>转载请注明<a href="http://pages.cs.wisc.edu/~vernon/cs367/notes/9.BST.html" target="_blank" rel="noopener">文章出处</a>，如有侵权请联系 <a href="mailto:flyliufu@gmail.com" target="_blank" rel="noopener">flyliufu@gmail.com</a> 立删。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>二叉查找树（binary search tree , BST）是一种特殊且重要的二叉树，在<code>BST</code> 中每个节点存储一些信息包括一个唯一的键值对（Key Value），并且还有可能有一些相关联的数据。一个二叉树当且仅当（iff）是二叉查找树时候，它的每个节点n在二叉树中应满足：</p>
<pre><code>1. 所有n 的左子树中的 key 值都应该小于 n 的 key 值，并且
2. 所有 n 的右子树中的 key 值都应大于 n 的 key 值。
</code></pre><p>注意：如果允许相同的 key 值出现，那么该节点即可以在 n 的左子树，也可以在 n 的右子树（但不能同时在两边），在这个前提下，下面我们的教程假设不允许重复值出现。</p>
<p>​    </p>
<p>​    下面是一些每个节点仅仅存储了一个整型数值的 BST </p>
<p><img src="/images/二叉树/bst1.jpg" alt="BST"></p>
<p>​    </p>
<p>​    下面这些不是 BST</p>
<p><img src="/images/二叉树/bst2.jpg" alt="非 BST"></p>
<p>左边这个5比6小（应该在左子树4的右子节点），右边这个6比7小（应该在5 的右子节点）。</p>
<p>注意不止一种 BST 可以存储相同的键值对，举个栗子下面这张图中的两个 BST 都是存储了相同的整型键：</p>
<p>​                                <img src="/images/二叉树/sameBSTs.jpg" alt="非 BST">    </p>
<p>二叉搜索树很重要的原因是使用BST可以有效地执行以下操作：</p>
<pre><code>1. 添加键值对
   2. 决定一个键值对在树中的位置
   3. 从树中删除键值对
   4. 打印排序后的所有键值对
</code></pre><hr>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>以下那些二叉树是BST？哪些不是？为什么？</li>
<li>用什么排序（preorder 先根排序, postorder 后根排序, inorder 中根排序, or level-order） 可以以顺序输出节点值？</li>
</ol>
<p><img src="/images/二叉树/question1.png" alt="非 BST"></p>
<hr>
<h2 id="实现二叉搜索树"><a href="#实现二叉搜索树" class="headerlink" title="实现二叉搜索树"></a>实现二叉搜索树</h2><p>为了实现一个二叉搜索树（BST）我们将要使用两个类：一个是树节点（tree node）、一个是二叉搜索树本身，下面定义的类是假设节点只存储键值，没有关联数据。因为大多数的 BST 操作都是比较 key 值，我们把 key 的类型设置为<code>Comparable</code> (不是 <code>Object</code>)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreenode</span> </span>&#123;</span><br><span class="line">   <span class="comment">// *** fields ***</span></span><br><span class="line">   <span class="keyword">private</span> Comparable key;</span><br><span class="line">   <span class="keyword">private</span> BinaryTreenode left, right;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// *** methods ***</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// constructor</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreenode</span><span class="params">(Comparable k, BinaryTreenode l, BinaryTreenode r)</span> </span>&#123;</span><br><span class="line">       key = k;</span><br><span class="line">       left = l;</span><br><span class="line">       right = r;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// access to fields</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Comparable <span class="title">getKey</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> key;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> BinaryTreenode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> left;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> BinaryTreenode <span class="title">getRight</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> right;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// change fields</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(Comparable k)</span> </span>&#123;key = k;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(BinaryTreenode l)</span> </span>&#123;left = l;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(BinaryTreenode r)</span> </span>&#123;right = r;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">  <span class="comment">// *** fields ***</span></span><br><span class="line">  <span class="keyword">private</span> BinaryTreenode root; <span class="comment">// ptr to the root of the BST</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// *** methods ***</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123; root = <span class="keyword">null</span>; &#125; <span class="comment">// constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Comparable key)</span> <span class="keyword">throws</span> DuplicateException </span>&#123;...&#125;</span><br><span class="line">      <span class="comment">// add key to this BST; error if it is already there</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Comparable key)</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="comment">// remove the node containing key from this BST if it is there;</span></span><br><span class="line">      <span class="comment">// otherwise, do nothing</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lookup</span><span class="params">(Comparable key)</span> </span>&#123;...&#125;</span><br><span class="line">     <span class="comment">// if key is in this BST, return true; otherwise, return false</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(PrintWriter p)</span> </span>&#123;...&#125;</span><br><span class="line">     <span class="comment">// print the values in this BST in sorted order (to p)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了实现 BST 对应每个 key 存储数据我们需要使用下列定义类：(和上面有些不一样，我不会标红)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreenode</span> </span>&#123;</span><br><span class="line">   <span class="comment">// *** fields ***</span></span><br><span class="line">   <span class="keyword">private</span> Comparable key;</span><br><span class="line">   <span class="keyword">private</span> Object data;</span><br><span class="line">   <span class="keyword">private</span> BinaryTreenode left, right;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// *** methods ***</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// constructor</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreenode</span><span class="params">(Comparable k, Object d, BinaryTreenode l, BinaryTreenode r)</span> </span>&#123;</span><br><span class="line">       key = k;</span><br><span class="line">       data = d;</span><br><span class="line">       left = l;</span><br><span class="line">       right = r;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> data;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object ob)</span> </span>&#123; data = ob; &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">  <span class="comment">// *** fields ***</span></span><br><span class="line">  <span class="keyword">private</span> BinaryTreenode root; <span class="comment">// ptr to the root of the BST</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// *** methods ***</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123; root = <span class="keyword">null</span>; &#125; <span class="comment">// constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Comparable key, Object data)</span> <span class="keyword">throws</span> DuplicateException </span>&#123;...&#125;</span><br><span class="line">      <span class="comment">// add key and associated data to this BST;</span></span><br><span class="line">      <span class="comment">// error if key is already there</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Comparable key)</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="comment">// remove the node containing key from this BST if it is there;</span></span><br><span class="line">      <span class="comment">// otherwise, do nothing</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(Comparable key)</span> </span>&#123;...&#125;</span><br><span class="line">     <span class="comment">// if key is in this BST, return its associated data; otherwise, return null</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(PrintWriter p)</span> </span>&#123;...&#125;</span><br><span class="line">     <span class="comment">// print the values in this BST in sorted order (to p)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从现在开始，我们将假设BST 只存储 key 值。没有关联数据，我们还假设 <code>null</code> 是一个无效的 key 值(也就是说，如果一些人尝试添加或查询一个 <code>null</code> 值会导致异常)。</p>
<hr>
<h2 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h2><p>一般情况下，决定给定的值放在BST 中的什么位置，通常我们会从树的根节点开始然后决定从那里查找：</p>
<ol>
<li>是不是根节点</li>
<li>也许是要的左子树</li>
<li>也许是根的右子树</li>
</ol>
<p>还有两种基本情况：</p>
<ol>
<li>树是空的 ，返回false</li>
<li>给定的值是根节点，返回 true</li>
</ol>
<p>如果基本情况中不包含，在适当的子树上会循环查找，如果所有的值都小于根(root) 的值就会查找左子树反之就会查找右子树。不可能同时查找两个子树,如果我们查找的值小于根的值，那它只可能在根的左子树，大于也只可能在右子树</p>
<p><code>lookup</code> 的代码用了一个辅助的递归函数和其同名（也就是说重载了 <code>lookup</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lookup</span><span class="params">(Comparable k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookup(root, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lookup</span><span class="params">(BinaryTreenode T, Comparable k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (T.getKey().equals(k)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (k.compareTo(T.getKey()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       	 <span class="comment">// k &lt; this node's key; look in left subtree</span></span><br><span class="line">		<span class="keyword">return</span> lookup(T.getLeft(), k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// k &gt; this node's key; look in right subtree</span></span><br><span class="line">		<span class="keyword">return</span> lookup(T.getRight(), k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们用下面这个 BST 来阐明一下工作原理：</p>
<p><img src="/images/二叉树/lookupBST.jpg" alt></p>
<p>​        </p>
<p>我们查找<code>12</code></p>
<p><img src="/images/二叉树/lookup12.jpg" alt></p>
<p>​    </p>
<ol>
<li>12小于13所以来到左子树</li>
<li>12大于9 所以到右子树</li>
<li><p>找到了！</p>
<p> 们查找<code>15</code> 会发生什么    </p>
</li>
</ol>
<p><img src="/images/二叉树/lookup15.jpg" alt></p>
<p>​    </p>
<ol>
<li>15大于13查找右子树</li>
<li>15小于16查找左子树</li>
<li>左子树不存在返回 false</li>
</ol>
<p>BST 中查找一个值需要消耗多少时间呢？注意一次查找总是从根节点向下到叶节点，在最坏的情况下走过每一个节点最终到叶节点，因此，最坏情况的时间是从根到叶节点最长路径的长度的比例（树的高度）</p>
<p>通常情况下，我们想知道函数查找存储在树中的值的数量需要多少时间，换句话来说，BST 中节点数量和树高度的关系是什么？这要依赖树的”图形（shape）”。在最坏的情况下所有的节点只有一个子节点，这个树本质上来说就是一个链表结构。举个栗子：</p>
<p><img src="/images/二叉树/worst-case.png" alt></p>
<p>这棵树有5个节点，并且高度也是5，当搜索数值在16 到 19 或 21 到 19 的时候需要从根节点到叶节点全走一遍，（也包括值为20 的节点）需要与树中节点数量成比的时间。</p>
<p>在最好的情况下所有节点都有两个子节点且所有叶节点在相同的深度。栗子：</p>
<p><img src="/images/二叉树/fulltree.jpg" alt></p>
<p>这棵树有7个节点且高度是3，通常一棵树像这样（完全二叉树）高度大约是 log<sub>2</sub>(N)， N 是树节点的个数，公式的值粗略的是用 N 除以 2得到 0 的次数。栗子：</p>
<p>7/2 = 3      // 除 2 一次<br>3/2 = 1      // 除 2 二次<br>1/2 = 0      // 除 2 三次, 结果为 0 退出</p>
<p>所以 log<sub>2</sub>(7) 值近似等于3。</p>
<p>使用 log<sub>2</sub>的原因（而不是 log<sub>3</sub>）是因为在一个 BST 中每个非叶节点都有两个子节点，根的每个子树在整树中的的数量占1/2（大约是），所以从根到叶节点的长度会和我们用 N 除以2 的次数一样。</p>
<p>然而，当我们使用大 O 记号法来表示时候，我们仅认为 N个节点满二叉树的高度是 O(log N) — 我们舍弃了底数 “2”，因为 log<sub>2</sub>(N) 可以和任意一个常量 k 为底的对数log<sub>k</sub>(N) 成比 ，也就是说 任意常量 B，k 和任意值 N 都有：</p>
<p>log<sub>B</sub>(N) = log<sub>k</sub>(N) / log<sub>k</sub>(B)</p>
<p>并且在大 O 记号法中我们通常会省略常数因子。</p>
<p>总结：在 BST 中查询最坏情况所需时间是 O(树的高度)。在最坏的情况下（一个“链表”树）是 O(N)，N 是树中节点个数，最好的情况下（一个“满”树）是 O(log N)。</p>
<hr>
<p>##添加函数</p>
<p>一个新的节点应该在 BST 的那里？答案很简单：就是你需要用<code>lookup</code> 在哪里找到它！如果你不放在那里那么以后你也不可能找的到。</p>
<p><code>insert</code> 函数代码在下面，需要注意的是：</p>
<ol>
<li>我们假设不允许添加重复的值（如果试图添加一个重复的值会导致异常）。</li>
<li>BST 类的 <code>insert</code> 函数在树为空的时候只添加key，另外它用了一个辅助的递归函数执行添加操作。</li>
<li>包含新值的节点总是作为叶节点添加在 BST 中。</li>
</ol>
<p>（talk is cheap, show me the code）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Comparable k)</span> <span class="keyword">throws</span> DuplicateException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> BinaryTreenode(k, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> insert(root, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(BinaryTreenode T, Comparable k)</span> <span class="keyword">throws</span> DuplicateException </span>&#123;</span><br><span class="line"><span class="comment">// precondition: T != null</span></span><br><span class="line">    <span class="keyword">if</span> (T.getKey().equals(k)) <span class="keyword">throw</span> <span class="keyword">new</span> DuplicateException();</span><br><span class="line">    <span class="keyword">if</span> (k.compareTo(T.getKey()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// add k as left child of T if it doesn't already have one</span></span><br><span class="line">        <span class="comment">// else insert into T's left subtree</span></span><br><span class="line">        <span class="keyword">if</span> (T.getLeft() == <span class="keyword">null</span>) T.setLeft( <span class="keyword">new</span> BinaryTreenode(k, <span class="keyword">null</span>, <span class="keyword">null</span>) );</span><br><span class="line">        <span class="keyword">else</span> insert(T.getLeft(), k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// here when k &gt; T's key</span></span><br><span class="line">        <span class="comment">// insert k as right child of T if it doesn't already have one</span></span><br><span class="line">        <span class="comment">// else insert into T's right subtree</span></span><br><span class="line">        <span class="keyword">if</span> (T.getRight() == <span class="keyword">null</span>) T.setRight( <span class="keyword">new</span> BinaryTreenode(k, <span class="keyword">null</span>, <span class="keyword">null</span>) );</span><br><span class="line">        <span class="keyword">else</span> insert(T.getRight(), k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来张图来阐明一下当我们用上面代码向例子中的 BST 添加一个 <code>15</code>  的时候发生了些什么</p>
<p><img src="/images/二叉树/insert15.jpg" alt></p>
<ol>
<li>15大于13 所以去右子树</li>
<li>15小于16去左子树</li>
<li>所以添加到16 的左子树中作为一个节点</li>
</ol>
<p>很容易看出来添加函数的复杂度和查询的的一样，在最坏的情况下一个路径要经过所有的节点到达叶节点</p>
<h3 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h3><p>如上所说，添加数值的顺序决定了 BST 的创建 （以不同的顺序添加相同的值会得到不同的 BST），以下面每个 1 到 7 数据的顺序绘制出 BST 来（顺序从左到右）</p>
<ol>
<li>5 3 7 6 2 1 4</li>
<li>1 2 3 4 5 6 7</li>
<li>4 3 5 2 6 1 7</li>
</ol>
<hr>
<h2 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h2><p>如你所愿，删除一个节点需要查询定位该节点以删除。下面这是删除函数的大概结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Comparable k)</span> </span>&#123;</span><br><span class="line">    root = delete(root, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BinaryTreenode <span class="title">delete</span><span class="params">(BinaryTreenode T, Comparable k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (k.equals(T.getKey())) &#123;</span><br><span class="line">       <span class="comment">// T is the node to be removed</span></span><br><span class="line">       <span class="comment">// code must be added here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k.compareTo(T.getKey()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        T.setLeft( delete(T.getLeft(), k) );</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        T.setRight( delete(T.getRight(), k) );</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这段代码有几点需要注意的</p>
<ol>
<li>与<code>insert</code> 和 <code>lookup</code> 函数一样，BST 删除函数也用了一个辅助的，重载函数来做实际的操作。</li>
<li>如果 <code>k</code> 值不在树中，那么最终将调用辅助函数的 <code>T == null</code> ，不认为这是一个错误，因为在这种情况下树没有改变什么。</li>
<li>辅助的删除函数返回了一个值（更改树的一个引用（pointer））。为什么下面说：</li>
</ol>
<p>如果这个值对应的节点被删除了，有三个情况需要处理：</p>
<ol>
<li>删除的节点是个叶节点（没有子节点）。</li>
<li>删除的节点有一个子节点。</li>
<li>删除的节点有两个子节点。</li>
</ol>
<p>当删除的节点是叶节点时候，我们需要把删除的节点父节点对应的子节点设置为 <code>null</code> （或者如果删除的是根节点那么设置根节点为 <code>null</code> 并且它没有子节点），注意应该用下面之一的方式调用删除函数：</p>
<ol>
<li>root = delete(root, k);</li>
<li>T.setLeft( delete(T.getLeft(), k) );</li>
<li>T.setRight( delete(T.getRight(), k) );</li>
</ol>
<p>如果<code>delete</code> 返回值为 null，也会正确执行函数。</p>
<p>下面是说明一下如果在 BST 中包含<code>15</code> 时候删除从树中删除时候会发生什么</p>
<p><img src="/images/二叉树/remove15.jpg" alt></p>
<p>当删除的节点只有一个子节点的时候，我们可以简单的替换那个节点为它子节点然后返回子节点。如例子所示我们从 BST 中删除 <code>16</code>  后就成了（第二图所示）</p>
<p><img src="/images/二叉树/remove16.jpg" alt></p>
<p>下面的<code>delete</code> 是我们迄今为止讨论的两种情况的代码 （没有标红凑合看吧）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BinaryTreenode <span class="title">delete</span><span class="params">(BinaryTreenode T, Comparable k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (k.equals(T.getKey())) &#123;</span><br><span class="line">        <span class="comment">// T is the node to be removed</span></span><br><span class="line">        <span class="keyword">if</span> (T.getLeft() == <span class="keyword">null</span> &amp;&amp; T.getRight() == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (T.getLeft() == <span class="keyword">null</span>) <span class="keyword">return</span> T.getRight();</span><br><span class="line">        <span class="keyword">if</span> (T.getRight() == <span class="keyword">null</span>) <span class="keyword">return</span> T.getLeft();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// here if T has 2 children</span></span><br><span class="line">        <span class="comment">// code still needs to be added here...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k.compareTo(T.getKey()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        T.setLeft( delete(T.getLeft(), k) );</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T.setRight( delete(T.getRight(), k) );</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最复杂的情况是将要删除的节点有两个子节点，我们把要删除的节点称作 <code>n</code> 。我们不能把 <code>n</code> 替换为任意一个子节点，因为我们不知道怎么处理另一个，然而我们会替换 <code>n</code> 为另一个节点 <code>x</code> ，然后在树下（递归）删除节点 <code>x</code> </p>
<p>问题是那个节点可以让我们用来替换节点 <code>n</code> ，我们必须选择一个节点保证树还是一个 BST；也就是说所有<code>n</code> 左子树的值都要比右子树的小，所有 <code>n</code> 节点右子树的值都要比左子树的大。这样的话有两种可能性：在左子树下面的最大值，或者右子树的最小值。我们任意决定一个用右子树的节点（最小值）</p>
<p>为了找到这个节点，我们只需在右子树中一直去查找左子节点，因为相对小的值总是在左子树上。一旦找到这个节点，我们复制它的 key 值到节点 <code>n</code> ，然后递归删除被复制的节点，下面是删除函数的最终版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BinaryTreenode <span class="title">delete</span><span class="params">(BinaryTreenode T, Comparable k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (k.equals(T.getKey())) &#123;</span><br><span class="line">       <span class="comment">// T is the node to be removed</span></span><br><span class="line">       <span class="keyword">if</span> (T.getLeft() == <span class="keyword">null</span> &amp;&amp; T.getRight() == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (T.getLeft() == <span class="keyword">null</span>) <span class="keyword">return</span> T.getRight();</span><br><span class="line">       <span class="keyword">if</span> (T.getRight() == <span class="keyword">null</span>) <span class="keyword">return</span> T.getLeft();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// here if T has 2 children</span></span><br><span class="line">       BinaryTreenode tmp = smallestNode(T.getRight());</span><br><span class="line">       <span class="comment">// copy key field from tmp to T</span></span><br><span class="line">       T.setKey( tmp.getKey() );</span><br><span class="line"></span><br><span class="line">       <span class="comment">// now delete tmp from T's right subtree and return</span></span><br><span class="line">       T.setRight( delete(T.getRight(), tmp.getKey()) );</span><br><span class="line">       <span class="keyword">return</span> T;</span><br><span class="line">       </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k.compareTo(T.getKey()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         T.setLeft( delete(T.getLeft(), k) );</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         T.setRight( delete(T.getRight(), k) );</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个 BST 树有些不一样，让我们来看看当我们要从树中删除13的时候会发生什么：</p>
<p><img src="/images/二叉树/remove13.jpg" alt></p>
<ol>
<li>原始 BST 定位到<code>13</code> 的位置</li>
<li>进入到右子树</li>
<li>到左子节点</li>
<li>再到左子节点，这是最后一个（叶节点）</li>
<li>把删除节点替换为右子树的叶节点</li>
<li>删除叶节点。</li>
</ol>
<hr>
<h3 id="小测验-1"><a href="#小测验-1" class="headerlink" title="小测验"></a>小测验</h3><p>尝试写一下上面的辅助函数 <code>smallestNode</code> 。函数定义已经给了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BinaryTreenode <span class="title">smallestNode</span><span class="params">(BinaryTreenode T)</span></span></span><br><span class="line"><span class="function"><span class="comment">// precondition: T is not null</span></span></span><br><span class="line"><span class="function"><span class="comment">// postcondition: return the node in the subtree rooted at T that</span></span></span><br><span class="line"><span class="function"><span class="comment">//                has the smallest value</span></span></span><br></pre></td></tr></table></figure>
<hr>
<p>删除函数的复杂度是什么样的呢？</p>
<p>如果被删除的节点只有一个或者没有子节点，那么删除函数从根（root）到那个节点只能“走一条路”。所以最坏的情况下时间和树的高度成正比（和<code>lookup</code> 和 <code>insert</code> 一样）</p>
<p>如果将要被删除的节点有两个子节点，下面这几点需要执行：</p>
<ol>
<li>找到要删除的节点（从根节点到该节点）</li>
<li>找到右子树最小的节点<code>x</code> （一直向下到叶节点）</li>
<li>递归去删除节点<code>x</code> （步骤 2 的路径再走一次）</li>
</ol>
<p>所以最坏的情况下，从根到叶节点一个路径走了两次。因为我们不考虑常数因子，所以最坏的情况下时间和树的高度成正比</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个二叉搜索树（BST）可以存储任何实现了<code>Comparable</code> 接口的对象 （也就是说需要定义<code>compareTo</code> 函数）。一个 BST 也可以用来存储 <code>Comparable</code> 对象加一些关联数据。用二叉搜索树（而不是说链表）的优势在于如果树是一个合理的平衡的（图形上来看更像是一棵”满”二叉树，而不是像“链”式树），添加、查询、删除操作全部能以<code>O(log N)</code> 的时间复杂度执行，N 是存储的项目数，而链表虽然添加可以做到<code>O(1)</code> 但删除、查询需要 <code>O(N)</code> 的时间复杂度。</p>
<p>对数时间复杂度通常要比线性的时间快的多。举个例子：如果 N = 1,000,000；log<sub>2</sub>N = 20。</p>
<p>当然，记住很重要的一点一个“链表”树（第一个节点只有一个子节点），最坏的时间复杂度对于添加、查询、删除需要<code>O(N)</code>。</p>
<h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><p>如有错误欢迎纠错，发送邮件 <a href="mailto:flyliufu@sina.com" target="_blank" rel="noopener">flyliufu@sina.com</a> 欢迎您的宝贵意见~。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://flyliufu.github.io/2017/06/03/表单验证的思路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fu Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/9735870?v=3&u=33ed681a589c432a123bbdc242b25d56a1a0ac7b&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My way of learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/03/表单验证的思路/" itemprop="url">
                  表单验证的思路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-03T09:49:01+08:00">
                2017-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/06/03/表单验证的思路/" class="leancloud_visitors" data-flag-title="表单验证的思路">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>​    项目中经常会遇到一些表单验证问题，最烦人的是需要在所有 <code>EditText</code>  全部符合要求（我们项目是只判断输入框不为空就成）时候再对提交按钮做可点的操作。</p>
<p>​    目前我能想到的也就是针对每个<code>EditText</code> 添加 <code>TextWatcher</code>  然后再判断是否为空然后设置按钮的状态，怎么操作呢？设置几个 boolean 值每一个值对应一个文本框的状态符合为 <code>true</code> 不符合为 <code>false</code> ? 太 low 了不是么最后还要判断一堆的变量是否为 <code>true</code> ！</p>
<p>​    说下我的解决方案：逻辑运算，对就是这个东西大学学过逻辑电路相关课程一定对这东西不陌生，基本的运算有 与<code>&amp;</code>，或 <code>|</code> ，非 <code>~</code> ，异或<code>^</code> 等等，如果我想验证一个表单中包含三个输入 <code>111</code>  表示全部符合，<code>000</code> 表示全不符合，同理有其他几种情况不一一列举。</p>
<p>​    上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// @param flag 是一个文本是否满足验证条件</span></span><br><span class="line"><span class="comment">// @param n 是 EditText 标志</span></span><br><span class="line"><span class="comment">// 验证登录界面是否可用公用方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validRegister</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// mTvRegister 是我的一个  Button 在符合条件时候可用</span></span><br><span class="line">  mTvRegister.setEnabled((flag ? (registerState ^= n) : (registerState |= n)) == <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    上面这个是个公用方法调用的时候如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnTextChanged</span>(value = &#123; R.id.et_register_password &#125;, callback = OnTextChanged.Callback.TEXT_CHANGED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRegister1</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  validRegister(TextUtils.isEmpty(s), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnTextChanged</span>(value = &#123; R.id.et_register_name &#125;, callback = OnTextChanged.Callback.TEXT_CHANGED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRegister2</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  validRegister(TextUtils.isEmpty(s), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnTextChanged</span>(value = &#123; R.id.et_auth_code &#125;, callback = OnTextChanged.Callback.TEXT_CHANGED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRegister3</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  validRegister(TextUtils.isEmpty(s), <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    我用了<code>Butterknife</code> 简化了 <code>TextWatcher</code> 实现。关键就是 <code>n</code> 的值，我验证三个输入他们的值分别就是 <code>2</code>  的0，1，2 次方，N 个输入就到 N，公用方法内<code>boolean</code> 表达式值为 <code>2</code> 的 <code>N+1</code> 次方 减 <code>1</code> 我 验证是三个输入应该判断的值就是 <code>2</code>  的 <code>3</code> 次方 减  <code>1</code>  结果为 <code>7</code> 很简单吧。 其实还可以继续扩展通过这个 <code>int</code> 值知道我到底那个符合要求那个不符合。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://flyliufu.github.io/2017/05/26/Kotlin学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fu Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/9735870?v=3&u=33ed681a589c432a123bbdc242b25d56a1a0ac7b&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My way of learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/26/Kotlin学习/" itemprop="url">
                  Kotlin学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-26T09:29:44+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/原创/" itemprop="url" rel="index">
                    <span itemprop="name">原创</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/26/Kotlin学习/" class="leancloud_visitors" data-flag-title="Kotlin学习">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/9735870?v=3&u=33ed681a589c432a123bbdc242b25d56a1a0ac7b&s=400" alt="Fu Liu">
          <p class="site-author-name" itemprop="name">Fu Liu</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/flyliufu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fu Liu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "c05ff3bcca6e4d2ab2203d81b037e8e8",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  







  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("mnghEybRbMmn0L4nJGOpIz0B-gzGzoHsz", "3gyRmnknuevDYYAekIJXbpoL");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


  

</body>
</html>
