{"meta":{"title":"My way of learning","subtitle":null,"description":"","author":"Fu Liu","url":"https://flyliufu.github.io"},"pages":[{"title":"分类","date":"2017-03-08T06:33:46.000Z","updated":"2017-03-09T10:02:12.000Z","comments":false,"path":"categories/index.html","permalink":"https://flyliufu.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-03-08T06:24:37.000Z","updated":"2017-03-09T10:02:07.000Z","comments":false,"path":"tags/index.html","permalink":"https://flyliufu.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-03-14T06:46:30.000Z","updated":"2017-03-14T06:52:32.000Z","comments":true,"path":"about/index.html","permalink":"https://flyliufu.github.io/about/index.html","excerpt":"","text":"此处应该有个简历，但没想好怎么写"}],"posts":[{"title":"JVM-2：了解 jvm 中 java 对象","slug":"JVM-2","date":"2019-08-23T23:34:59.000Z","updated":"2019-08-25T04:31:23.154Z","comments":true,"path":"2019/08/24/JVM-2/","link":"","permalink":"https://flyliufu.github.io/2019/08/24/JVM-2/","excerpt":"","text":"了解 jvm 中 java 对象对象创建过程 只讨论普通对象，不包括数组、Class 对象。 虚拟机遇到 new 指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化过。如果没有需要执行相应操作（Chapter 7） 接下来虚拟机为对象分配内存，对象所需大小在类加载完成即可明确。内存分配分为两种方式： 指针碰撞：如果 java 堆内存是绝对规整的，使用的内存在一边，未使用在另一边，中间放着一个指针作为分界点指示器，分配内存的动作就是把指针向空闲方向移动对象大小的距离 空闲列表：如果 java 堆内存不是规整的，虚拟机就需要维护一个列表记录那些内存是可用的分配时候找出一块足够大的内存划分给对象。 选择哪种分配方式要看 java 堆是否规整，java 堆是否规整又和 GC 收集器是否带压缩整理功能决定。 创建对象在虚拟机中是非常频繁的，即使修改一个指针指向位置在并发环境下也并不是线程安全，解决这个问题有两种方案： 1. 对分配内存空间的动作进行同步处理 2. 把内存分配动作按线程划分在不同空间中进行，即每个线程在 java 堆中预先分配一小块内存称为本地线程分配缓冲（Thread Local Allocation Buffer , TLAB）线程内存分配在自己的 TLAB 上，只有当 TLAB 用完并且分配新的时候，才需同步锁定。是否使用 TLAB 用 `-XX:+/-UseTLAB` 参数 内存分配完成后虚拟机要将分配到的内存初始化为零值（不包括对象头），如果用 TLAB 这一操作可提前到 TLAB 分配时进行，这步操作保证了对象的实例字段在不赋值的时候就可以使用，程序访问到的是属性对应的零值。 虚机机需要对对象做必要的设置，例如对象是那个类的实例、如何找到类的元数据信息、对象的哈希码、对你的 GC 分代年龄等信息。 以上操作完成后从虚拟机的角度来说已经完成一个新对象已经产生，但从 java 角度来说才刚开始 —— &lt;init&gt; 方法还没执行，一般情况执行完 new 指令后会接着执行 &lt;init&gt; 把对象按程序员的意愿进行初始化，至此对象才完全产生出来。 对象内存布局 在 HotSpot 虚拟机中对象内存的布局分为3块区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding） HotSpot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、 偏向时间戳等 对象的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例， 如果对象是一个 java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通的 java 对象的元数据信息确定 java 对象的大小，但从数组的元数据信息无法确定数组的大小 实例数据部分是对你真正存储的的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论在父类继承还是子类定义全部需要记录下来。同同宽度的字段总是分配到一起，在这前提下父类中定义的变量会出现在子类之前，如果 CompatField 参数值为 true （默认为 true） 子类中较窄的变量也可能插入到父类变量的空隙之路 对象填充不是必然存在的，也没特殊含义，HotSpot 虚拟机中要求对象大小必须是8的整数倍，对象头是8的整数倍，当实例数据部分没有对齐时需要通过对齐填充来补全。对象的访问java 程序需要通过栈上的 reference 数据来操作堆上的具体对象， JVM 虚拟机规范中只支付宝了一个指向对象的引用，并没有定义这个引用该通过何种方式去定位，所以具体实现也取决于虚拟机实现。 目前主流的访问方式有两种： 句柄访问 java 堆中会划分出一块内存来作为句柄池，reference 中存储的是对象的句柄地址而句柄中包含了对象的实例数据与类型数据各自的具体地址信息。 使用该方式好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（GC 时候移动对象是非常普遍的行为）时只会改变句柄中实例数据的指针， reference 本身不需要修改 直接指针访问 直接指针会指向堆中实例数据，实例数据中会指向其实际类型数据 使用本方式的最大好处就是速度更快了，节省了一次指针定位的时间开销，在 HotSpot 中使用的是本方式访问对象","categories":[{"name":"原创","slug":"原创","permalink":"https://flyliufu.github.io/categories/原创/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://flyliufu.github.io/tags/JAVA/"},{"name":"JVM","slug":"JVM","permalink":"https://flyliufu.github.io/tags/JVM/"}]},{"title":"JVM-1:内存区域与内存溢出","slug":"JVM-1","date":"2019-08-13T01:42:27.000Z","updated":"2019-08-23T23:39:27.443Z","comments":true,"path":"2019/08/13/JVM-1/","link":"","permalink":"https://flyliufu.github.io/2019/08/13/JVM-1/","excerpt":"","text":"内存区域与内存溢出运行时数据区域 java 虚拟机在执行 java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。程序计数器 一块较小的内存空间，可以看作当前线程所执行的字节码行号指示器 改变计数器的值选取下一条需要执行字节码指令。（分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个计数器） 一个确定时刻一个处理器（多核处理器是一个内核）只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，所以每个线程都需要有一个独立的程序计数器我们称这类内存区域第线程私有内存 当线程正在执行 java 方法时候记数器记录的是正在执行的虚拟机字节码指令地址，如果是 Native 方法计数器值为空（Undefined） 此区域是唯一一个在 java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域Java 虚拟机栈 线程私有，生命周期与线程相同 虚拟机栈描述的是 java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 局部变量表存放了8种基本数据类型、对象引用（不是对象，reference 类型）、returnAddress 类型（指向一条字节码指令的地址）。 long、double 占用了两个局部空间其余占一个。 局部变量表所需内存空间在编译期间完成分配，运行方法的时候所需多大空间固定且不变。 该区域有两种异常状况：如果线程请求栈的深度大于虚拟机允许的深度抛出 StackOverflowError；如果虚拟机栈可以动态扩展，当扩展时无法申请足够的内存抛出 OutOfMemoryError 异常本地方法栈 和虚拟机栈发挥的作用相似，该区域为本地方法服务。 在 HotSpot 虚拟机中该区域和虚拟机栈合并在一起 会抛出 StackOverflowError OutOfMemoryErrorjava 堆 java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建 java 堆从内存回收的角度来看由于采用分代回收算法所以可以分为：新生代、老年代","categories":[{"name":"原创","slug":"原创","permalink":"https://flyliufu.github.io/categories/原创/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://flyliufu.github.io/tags/JAVA/"},{"name":"JVM","slug":"JVM","permalink":"https://flyliufu.github.io/tags/JVM/"}]},{"title":"初识 R","slug":"初识 R","date":"2018-06-07T05:50:42.000Z","updated":"2018-06-12T01:22:28.933Z","comments":true,"path":"2018/06/07/初识 R/","link":"","permalink":"https://flyliufu.github.io/2018/06/07/初识 R/","excerpt":"","text":"初识 R​ R 语言是什么维基百科对R 语言 的描述总结就是一个很牛逼的绘图不仅仅限于绘图的语言。至于我为什么要学习这个语言，现在我做安卓开发，但一直和代码打交道受到中国 IT 界环境影响，即使我想一直写代码下去，可能也没有地方让我去永远写下去。为了自己以后有饭吃需要学习些东西，经人指点可以转而做数据分析师，虽然道阻且长但还要砥砺前行，在此写下此博文算是立个 flag，文章写的不好多多交流！ 一. R 数据结构​ R 语言中数据结构有 标量、向量、矩阵、数组、数据框和列表。 这些名词听起来和很多其他语言都有共通的名称，但就我懂的 Java 语言来说还是有些区别下面一一来学习 标量​ 标量很像 Java 中的变量，如下所示可以定义一个标量 123f &lt;- 3g &lt;- \"US\"h &lt;- TRUE 说明几点 R 中赋值操作符是&lt;- 当然可以用= 但不提倡 R 中没有明确非要以; 结束（至少我目前没发现） R 中是大小写敏感的语言 向量​ 向量是用来存放数值、字符型或是逻辑型数据的一维数组，用函数c() 来创建。 123a &lt;- c(1,2,3,4,5)b &lt;- c(\"a\",\"b\",\"c\",\"D\")c &lt;- c(TRUE,FALSE,TRUE,FALSE,TRUE,FALSE,TRUE,FALSE) 在 R 中逻辑值真假为TRUE FALSE 全大写 ​ 访问向量中的数据我总结的是有两种方式位置法和区间法 1234# 访问 a 的2，4 的元素a[c(2,4)] # 输出 2 4 # 访问 b 的1 到 3 的元素b[1:3] # 输出 a b c 在 R 中访问的并不是下标从0开始，而是从1开始的位置，区间比较好理解就是从1 到 3 的数据 矩阵​ 说到矩阵第一个想到线性代数，没错就是一样的东西，在Java 中更像是个二维数组，同样可以创建上面三种类型的矩阵，使用函数matrix() 创建 123# outMatrix &lt;- matrix(data = dataVec, nrow = nrow, ncol = ncol, byrow = byrow)y &lt;- matrix(1:20,nrow = 5, ncol = 4)print(y) data ：创建矩阵数据 nrow ：行数 ncol ：列数 byrow ：按行还是按列填充，TRUE 或 FALSE 默认按列 相关参数很多不能一一列明 可以使用在线帮助文档help(matrix) 获取帮助 ​ 访问矩阵的数据 1234567891011# 创建一个两行五列的矩阵如下x &lt;- matrix(1:10, nrow = 2)print(x)## 输出第二行print(x[2,])## 输出第二列print(x[,2])## 输出1行四列print(x[1,4])## 范围输出print(x[1,c(4,5)]) 非常直观易懂，但还是希望多打代码去练习，这样才能加深印象。","categories":[{"name":"原创","slug":"原创","permalink":"https://flyliufu.github.io/categories/原创/"}],"tags":[{"name":"R","slug":"R","permalink":"https://flyliufu.github.io/tags/R/"}]},{"title":"二叉树之二叉查找树","slug":"二叉树","date":"2018-02-07T05:50:42.000Z","updated":"2018-02-11T06:13:18.223Z","comments":true,"path":"2018/02/07/二叉树/","link":"","permalink":"https://flyliufu.github.io/2018/02/07/二叉树/","excerpt":"","text":"二叉查找树 Binary Search Tree\u0010转载请注明文章出处，如有侵权请联系 flyliufu@gmail.com 立删。 概述二叉查找树（binary search tree , BST）是一种特殊且重要的二叉树，在BST 中每个节点存储一些信息包括一个唯一的键值对（Key Value），并且还有可能有一些相关联的数据。一个二叉树当且仅当（iff）是二叉查找树时候，它的每个节点n在二叉树中应满足： 1. 所有n 的左子树中的 key 值都应该小于 n 的 key 值，并且 2. 所有 n 的右子树中的 key 值都应大于 n 的 key 值。 注意：如果允许相同的 key 值出现，那么该节点即可以在 n 的左子树，也可以在 n 的右子树（但不能同时在两边），在这个前提下，下面我们的教程假设不允许重复值出现。 ​ ​ 下面是一些每个节点仅仅存储了一个整型数值的 BST ​ ​ 下面这些不是 BST 左边这个5比6小（应该在左子树4的右子节点），右边这个6比7小（应该在5 的右子节点）。 注意不止一种 BST 可以存储相同的键值对，举个栗子下面这张图中的两个 BST 都是存储了相同的整型键： ​ 二叉搜索树很重要的原因是使用BST可以有效地执行以下操作： 1. 添加键值对 2. 决定一个键值对在树中的位置 3. 从树中删除键值对 4. 打印排序后的所有键值对 问题 以下那些二叉树是BST？哪些不是？为什么？ 用什么排序（preorder 先根排序, postorder 后根排序, inorder 中根排序, or level-order） 可以以顺序输出节点值？ 实现二叉搜索树为了实现一个二叉搜索树（BST）我们将要使用两个类：一个是树节点（tree node）、一个是二叉搜索树本身，下面定义的类是假设节点只存储键值，没有关联数据。因为大多数的 BST 操作都是比较 key 值，我们把 key 的类型设置为Comparable (不是 Object)。 1234567891011121314151617181920212223242526272829303132333435363738394041class BinaryTreenode &#123; // *** fields *** private Comparable key; private BinaryTreenode left, right; // *** methods *** // constructor public BinaryTreenode(Comparable k, BinaryTreenode l, BinaryTreenode r) &#123; key = k; left = l; right = r; &#125; // access to fields public Comparable getKey() &#123;return key;&#125; public BinaryTreenode getLeft() &#123;return left;&#125; public BinaryTreenode getRight() &#123;return right;&#125; // change fields public void setKey(Comparable k) &#123;key = k;&#125; public void setLeft(BinaryTreenode l) &#123;left = l;&#125; public void setRight(BinaryTreenode r) &#123;right = r;&#125;&#125;class BST &#123; // *** fields *** private BinaryTreenode root; // ptr to the root of the BST // *** methods *** public BST() &#123; root = null; &#125; // constructor public void insert(Comparable key) throws DuplicateException &#123;...&#125; // add key to this BST; error if it is already there public void delete(Comparable key) &#123;...&#125; // remove the node containing key from this BST if it is there; // otherwise, do nothing public boolean lookup(Comparable key) &#123;...&#125; // if key is in this BST, return true; otherwise, return false public void print(PrintWriter p) &#123;...&#125; // print the values in this BST in sorted order (to p)&#125; 为了实现 BST 对应每个 key 存储数据我们需要使用下列定义类：(和上面有些不一样，我不会标红) 123456789101112131415161718192021222324252627282930313233343536373839class BinaryTreenode &#123; // *** fields *** private Comparable key; private Object data; private BinaryTreenode left, right; // *** methods *** // constructor public BinaryTreenode(Comparable k, Object d, BinaryTreenode l, BinaryTreenode r) &#123; key = k; data = d; left = l; right = r; &#125; ... public Object getData() &#123;return data;&#125; public void setData(Object ob) &#123; data = ob; &#125; ...&#125;class BST &#123; // *** fields *** private BinaryTreenode root; // ptr to the root of the BST // *** methods *** public BST() &#123; root = null; &#125; // constructor public void insert(Comparable key, Object data) throws DuplicateException &#123;...&#125; // add key and associated data to this BST; // error if key is already there public void delete(Comparable key) &#123;...&#125; // remove the node containing key from this BST if it is there; // otherwise, do nothing public Object lookup(Comparable key) &#123;...&#125; // if key is in this BST, return its associated data; otherwise, return null public void print(PrintWriter p) &#123;...&#125; // print the values in this BST in sorted order (to p)&#125; 从现在开始，我们将假设BST 只存储 key 值。没有关联数据，我们还假设 null 是一个无效的 key 值(也就是说，如果一些人尝试添加或查询一个 null 值会导致异常)。 查询函数一般情况下，决定给定的值放在BST 中的什么位置，通常我们会从树的根节点开始然后决定从那里查找： 是不是根节点 也许是要的左子树 也许是根的右子树 还有两种基本情况： 树是空的 ，返回false 给定的值是根节点，返回 true 如果基本情况中不包含，在适当的子树上会循环查找，如果所有的值都小于根(root) 的值就会查找左子树反之就会查找右子树。不可能同时查找两个子树,如果我们查找的值小于根的值，那它只可能在根的左子树，大于也只可能在右子树 lookup 的代码用了一个辅助的递归函数和其同名（也就是说重载了 lookup） 12345678910111213141516public boolean lookup(Comparable k) &#123; return lookup(root, k);&#125;private static boolean lookup(BinaryTreenode T, Comparable k) &#123; if (T == null) return false; if (T.getKey().equals(k)) return true; if (k.compareTo(T.getKey()) &lt; 0) &#123; // k &lt; this node's key; look in left subtree return lookup(T.getLeft(), k); &#125; else &#123; // k &gt; this node's key; look in right subtree return lookup(T.getRight(), k); &#125;&#125; 让我们用下面这个 BST 来阐明一下工作原理： ​ 我们查找12 ​ 12小于13所以来到左子树 12大于9 所以到右子树 找到了！ 们查找15 会发生什么 ​ 15大于13查找右子树 15小于16查找左子树 左子树不存在返回 false BST 中查找一个值需要消耗多少时间呢？注意一次查找总是从根节点向下到叶节点，在最坏的情况下走过每一个节点最终到叶节点，因此，最坏情况的时间是从根到叶节点最长路径的长度的比例（树的高度） 通常情况下，我们想知道函数查找存储在树中的值的数量需要多少时间，换句话来说，BST 中节点数量和树高度的关系是什么？这要依赖树的”图形（shape）”。在最坏的情况下所有的节点只有一个子节点，这个树本质上来说就是一个链表结构。举个栗子： 这棵树有5个节点，并且高度也是5，当搜索数值在16 到 19 或 21 到 19 的时候需要从根节点到叶节点全走一遍，（也包括值为20 的节点）需要与树中节点数量成比的时间。 在最好的情况下所有节点都有两个子节点且所有叶节点在相同的深度。栗子： 这棵树有7个节点且高度是3，通常一棵树像这样（完全二叉树）高度大约是 log2(N)， N 是树节点的个数，公式的值粗略的是用 N 除以 2得到 0 的次数。栗子： 7/2 = 3 // 除 2 一次3/2 = 1 // 除 2 二次1/2 = 0 // 除 2 三次, 结果为 0 退出 所以 log2(7) 值近似等于3。 使用 log2的原因（而不是 log3）是因为在一个 BST 中每个非叶节点都有两个子节点，根的每个子树在整树中的的数量占1/2（大约是），所以从根到叶节点的长度会和我们用 N 除以2 的次数一样。 然而，当我们使用大 O 记号法来表示时候，我们仅认为 N个节点满二叉树的高度是 O(log N) — 我们舍弃了底数 “2”，因为 log2(N) 可以和任意一个常量 k 为底的对数logk(N) 成比 ，也就是说 任意常量 B，k 和任意值 N 都有： logB(N) = logk(N) / logk(B) 并且在大 O 记号法中我们通常会省略常数因子。 总结：在 BST 中查询最坏情况所需时间是 O(树的高度)。在最坏的情况下（一个“链表”树）是 O(N)，N 是树中节点个数，最好的情况下（一个“满”树）是 O(log N)。 ##添加函数 一个新的节点应该在 BST 的那里？答案很简单：就是你需要用lookup 在哪里找到它！如果你不放在那里那么以后你也不可能找的到。 insert 函数代码在下面，需要注意的是： 我们假设不允许添加重复的值（如果试图添加一个重复的值会导致异常）。 BST 类的 insert 函数在树为空的时候只添加key，另外它用了一个辅助的递归函数执行添加操作。 包含新值的节点总是作为叶节点添加在 BST 中。 （talk is cheap, show me the code） 123456789101112131415161718192021222324public void insert(Comparable k) throws DuplicateException &#123; if (root == null) &#123; root = new BinaryTreenode(k, null, null); &#125; else insert(root, k);&#125;private static void insert(BinaryTreenode T, Comparable k) throws DuplicateException &#123;// precondition: T != null if (T.getKey().equals(k)) throw new DuplicateException(); if (k.compareTo(T.getKey()) &lt; 0) &#123; // add k as left child of T if it doesn't already have one // else insert into T's left subtree if (T.getLeft() == null) T.setLeft( new BinaryTreenode(k, null, null) ); else insert(T.getLeft(), k); &#125; else &#123; // here when k &gt; T's key // insert k as right child of T if it doesn't already have one // else insert into T's right subtree if (T.getRight() == null) T.setRight( new BinaryTreenode(k, null, null) ); else insert(T.getRight(), k); &#125;&#125; 来张图来阐明一下当我们用上面代码向例子中的 BST 添加一个 15 的时候发生了些什么 15大于13 所以去右子树 15小于16去左子树 所以添加到16 的左子树中作为一个节点 很容易看出来添加函数的复杂度和查询的的一样，在最坏的情况下一个路径要经过所有的节点到达叶节点 小测验如上所说，添加数值的顺序决定了 BST 的创建 （以不同的顺序添加相同的值会得到不同的 BST），以下面每个 1 到 7 数据的顺序绘制出 BST 来（顺序从左到右） 5 3 7 6 2 1 4 1 2 3 4 5 6 7 4 3 5 2 6 1 7 删除函数如你所愿，删除一个节点需要查询定位该节点以删除。下面这是删除函数的大概结构： 12345678910111213141516171819public void delete(Comparable k) &#123; root = delete(root, k);&#125;private static BinaryTreenode delete(BinaryTreenode T, Comparable k) &#123; if (T == null) return null; if (k.equals(T.getKey())) &#123; // T is the node to be removed // code must be added here &#125; else if (k.compareTo(T.getKey()) &lt; 0) &#123; T.setLeft( delete(T.getLeft(), k) ); return T; &#125; else &#123; T.setRight( delete(T.getRight(), k) ); return T; &#125;&#125; 关于这段代码有几点需要注意的 与insert 和 lookup 函数一样，BST 删除函数也用了一个辅助的，重载函数来做实际的操作。 如果 k 值不在树中，那么最终将调用辅助函数的 T == null ，不认为这是一个错误，因为在这种情况下树没有改变什么。 辅助的删除函数返回了一个值（更改树的一个引用（pointer））。为什么下面说： 如果这个值对应的节点被删除了，有三个情况需要处理： 删除的节点是个叶节点（没有子节点）。 删除的节点有一个子节点。 删除的节点有两个子节点。 当删除的节点是叶节点时候，我们需要把删除的节点父节点对应的子节点设置为 null （或者如果删除的是根节点那么设置根节点为 null 并且它没有子节点），注意应该用下面之一的方式调用删除函数： root = delete(root, k); T.setLeft( delete(T.getLeft(), k) ); T.setRight( delete(T.getRight(), k) ); 如果delete 返回值为 null，也会正确执行函数。 下面是说明一下如果在 BST 中包含15 时候删除从树中删除时候会发生什么 当删除的节点只有一个子节点的时候，我们可以简单的替换那个节点为它子节点然后返回子节点。如例子所示我们从 BST 中删除 16 后就成了（第二图所示） 下面的delete 是我们迄今为止讨论的两种情况的代码 （没有标红凑合看吧） 123456789101112131415161718private static BinaryTreenode delete(BinaryTreenode T, Comparable k) &#123; if (T == null) return null; if (k.equals(T.getKey())) &#123; // T is the node to be removed if (T.getLeft() == null &amp;&amp; T.getRight() == null) return null; if (T.getLeft() == null) return T.getRight(); if (T.getRight() == null) return T.getLeft(); // here if T has 2 children // code still needs to be added here... &#125; else if (k.compareTo(T.getKey()) &lt; 0) &#123; T.setLeft( delete(T.getLeft(), k) ); return T; &#125; else &#123; T.setRight( delete(T.getRight(), k) ); return T; &#125;&#125; 最复杂的情况是将要删除的节点有两个子节点，我们把要删除的节点称作 n 。我们不能把 n 替换为任意一个子节点，因为我们不知道怎么处理另一个，然而我们会替换 n 为另一个节点 x ，然后在树下（递归）删除节点 x 问题是那个节点可以让我们用来替换节点 n ，我们必须选择一个节点保证树还是一个 BST；也就是说所有n 左子树的值都要比右子树的小，所有 n 节点右子树的值都要比左子树的大。这样的话有两种可能性：在左子树下面的最大值，或者右子树的最小值。我们任意决定一个用右子树的节点（最小值） 为了找到这个节点，我们只需在右子树中一直去查找左子节点，因为相对小的值总是在左子树上。一旦找到这个节点，我们复制它的 key 值到节点 n ，然后递归删除被复制的节点，下面是删除函数的最终版本： 12345678910111213141516171819202122232425private static BinaryTreenode delete(BinaryTreenode T, Comparable k) &#123; if (T == null) return null; if (k.equals(T.getKey())) &#123; // T is the node to be removed if (T.getLeft() == null &amp;&amp; T.getRight() == null) return null; if (T.getLeft() == null) return T.getRight(); if (T.getRight() == null) return T.getLeft(); // here if T has 2 children BinaryTreenode tmp = smallestNode(T.getRight()); // copy key field from tmp to T T.setKey( tmp.getKey() ); // now delete tmp from T's right subtree and return T.setRight( delete(T.getRight(), tmp.getKey()) ); return T; &#125; else if (k.compareTo(T.getKey()) &lt; 0) &#123; T.setLeft( delete(T.getLeft(), k) ); return T; &#125; else &#123; T.setRight( delete(T.getRight(), k) ); return T; &#125;&#125; 下面这个 BST 树有些不一样，让我们来看看当我们要从树中删除13的时候会发生什么： 原始 BST 定位到13 的位置 进入到右子树 到左子节点 再到左子节点，这是最后一个（叶节点） 把删除节点替换为右子树的叶节点 删除叶节点。 小测验尝试写一下上面的辅助函数 smallestNode 。函数定义已经给了： 1234private static BinaryTreenode smallestNode(BinaryTreenode T)// precondition: T is not null// postcondition: return the node in the subtree rooted at T that// has the smallest value 删除函数的复杂度是什么样的呢？ 如果被删除的节点只有一个或者没有子节点，那么删除函数从根（root）到那个节点只能“走一条路”。所以最坏的情况下时间和树的高度成正比（和lookup 和 insert 一样） 如果将要被删除的节点有两个子节点，下面这几点需要执行： 找到要删除的节点（从根节点到该节点） 找到右子树最小的节点x （一直向下到叶节点） 递归去删除节点x （步骤 2 的路径再走一次） 所以最坏的情况下，从根到叶节点一个路径走了两次。因为我们不考虑常数因子，所以最坏的情况下时间和树的高度成正比 总结一个二叉搜索树（BST）可以存储任何实现了Comparable 接口的对象 （也就是说需要定义compareTo 函数）。一个 BST 也可以用来存储 Comparable 对象加一些关联数据。用二叉搜索树（而不是说链表）的优势在于如果树是一个合理的平衡的（图形上来看更像是一棵”满”二叉树，而不是像“链”式树），添加、查询、删除操作全部能以O(log N) 的时间复杂度执行，N 是存储的项目数，而链表虽然添加可以做到O(1) 但删除、查询需要 O(N) 的时间复杂度。 对数时间复杂度通常要比线性的时间快的多。举个例子：如果 N = 1,000,000；log2N = 20。 当然，记住很重要的一点一个“链表”树（第一个节点只有一个子节点），最坏的时间复杂度对于添加、查询、删除需要O(N)。 联系我如有错误欢迎纠错，发送邮件 flyliufu@sina.com 欢迎您的宝贵意见~。","categories":[{"name":"翻译","slug":"翻译","permalink":"https://flyliufu.github.io/categories/翻译/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://flyliufu.github.io/tags/JAVA/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://flyliufu.github.io/tags/Algorithms/"}]},{"title":"表单验证的思路","slug":"表单验证的思路","date":"2017-06-03T01:49:01.000Z","updated":"2018-01-09T07:21:46.916Z","comments":true,"path":"2017/06/03/表单验证的思路/","link":"","permalink":"https://flyliufu.github.io/2017/06/03/表单验证的思路/","excerpt":"","text":"​ 项目中经常会遇到一些表单验证问题，最烦人的是需要在所有 EditText 全部符合要求（我们项目是只判断输入框不为空就成）时候再对提交按钮做可点的操作。 ​ 目前我能想到的也就是针对每个EditText 添加 TextWatcher 然后再判断是否为空然后设置按钮的状态，怎么操作呢？设置几个 boolean 值每一个值对应一个文本框的状态符合为 true 不符合为 false ? 太 low 了不是么最后还要判断一堆的变量是否为 true ！ ​ 说下我的解决方案：逻辑运算，对就是这个东西大学学过逻辑电路相关课程一定对这东西不陌生，基本的运算有 与&amp;，或 | ，非 ~ ，异或^ 等等，如果我想验证一个表单中包含三个输入 111 表示全部符合，000 表示全不符合，同理有其他几种情况不一一列举。 ​ 上代码： 12345678// @param flag 是一个文本是否满足验证条件// @param n 是 EditText 标志// 验证登录界面是否可用公用方法private void validRegister(boolean flag, int n) &#123; // mTvRegister 是我的一个 Button 在符合条件时候可用 mTvRegister.setEnabled((flag ? (registerState ^= n) : (registerState |= n)) == 7);&#125; ​ 上面这个是个公用方法调用的时候如下： 1234567891011121314@OnTextChanged(value = &#123; R.id.et_register_password &#125;, callback = OnTextChanged.Callback.TEXT_CHANGED)public void onRegister1(CharSequence s, int start, int before, int count) &#123; validRegister(TextUtils.isEmpty(s), 1);&#125;@OnTextChanged(value = &#123; R.id.et_register_name &#125;, callback = OnTextChanged.Callback.TEXT_CHANGED)public void onRegister2(CharSequence s, int start, int before, int count) &#123; validRegister(TextUtils.isEmpty(s), 2);&#125;@OnTextChanged(value = &#123; R.id.et_auth_code &#125;, callback = OnTextChanged.Callback.TEXT_CHANGED)public void onRegister3(CharSequence s, int start, int before, int count) &#123; validRegister(TextUtils.isEmpty(s), 4);&#125; ​ 我用了Butterknife 简化了 TextWatcher 实现。关键就是 n 的值，我验证三个输入他们的值分别就是 2 的0，1，2 次方，N 个输入就到 N，公用方法内boolean 表达式值为 2 的 N+1 次方 减 1 我 验证是三个输入应该判断的值就是 2 的 3 次方 减 1 结果为 7 很简单吧。 其实还可以继续扩展通过这个 int 值知道我到底那个符合要求那个不符合。","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://flyliufu.github.io/tags/JAVA/"},{"name":"Android","slug":"Android","permalink":"https://flyliufu.github.io/tags/Android/"}]},{"title":"Kotlin学习","slug":"Kotlin学习","date":"2017-05-26T01:29:44.000Z","updated":"2017-05-26T02:44:38.000Z","comments":true,"path":"2017/05/26/Kotlin学习/","link":"","permalink":"https://flyliufu.github.io/2017/05/26/Kotlin学习/","excerpt":"","text":"","categories":[{"name":"原创","slug":"原创","permalink":"https://flyliufu.github.io/categories/原创/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://flyliufu.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://flyliufu.github.io/tags/Kotlin/"}]},{"title":"Retrofit,OkHttp 多图文上传总结","slug":"Retrofit-OkHttp-多图文上传总结","date":"2017-03-29T06:19:15.000Z","updated":"2017-03-29T06:38:43.000Z","comments":true,"path":"2017/03/29/Retrofit-OkHttp-多图文上传总结/","link":"","permalink":"https://flyliufu.github.io/2017/03/29/Retrofit-OkHttp-多图文上传总结/","excerpt":"","text":"​ 最近在项目用到 Retrofit2 和 OkHttp3 整合做多图文上传遇到了一些问题整了半天搞的晕头转向终于搞定了，写个博文记录一下希望有人用到后可以帮助其解决遇到的问题。 123456/** * 上传文件方法 * @param path 路径 * @return 服务器返回JSON */@POST Observable&lt;String&gt; fileUpload(@Url String path, @Body RequestBody body); ​ 在接口类中声明该方法 1234567// 上面接口类的实例调用该方法 ServicesAPI .fileUpload(\"request/path\", filesToMultipartBodyParts(fileMap, params)).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread())// 处理返回的观察者，自己定义.subscribe(observer); 12345678910111213141516171819202122232425262728/** * 将文本类型，文件类型参数 转换成 MultipartBody * @param fileMap 文件路径 * @param params 请求参数 */@NonNull MultipartBody filesToMultipartBodyParts(Map&lt;String, String&gt; fileMap, Map&lt;String, String&gt; params) &#123; MultipartBody.Builder builder = new MultipartBody.Builder(); if (params != null &amp;&amp; !params.isEmpty()) &#123; // 放置一般数据类型 for (String key : params.keySet()) &#123; builder.addFormDataPart(key, params.get(key)); &#125; &#125; if (fileMap != null &amp;&amp; !fileMap.isEmpty()) &#123; // 放置文件类型 for (String key : fileMap.keySet()) &#123; File file = new File(fileMap.get(key)); if (!file.exists()) &#123; throw new RuntimeException(String.format(\"File not found : %s.\", fileMap.get(key))); &#125; // TODO: 16-4-2 这里为了简单起见，没有判断file的类型 RequestBody requestBody = RequestBody.create(MediaType.parse(\"image/png\"), file); builder.addFormDataPart(key, file.getName(), requestBody); &#125; &#125; return builder.setType(MultipartBody.FORM).build();&#125; ​ 其后就可以开心的上传文件了，有问题欢迎交流。","categories":[],"tags":[{"name":"网络框架","slug":"网络框架","permalink":"https://flyliufu.github.io/tags/网络框架/"}]},{"title":"算法学习总结1","slug":"算法学习总结1","date":"2017-03-25T01:51:17.000Z","updated":"2017-04-20T12:31:14.000Z","comments":true,"path":"2017/03/25/算法学习总结1/","link":"","permalink":"https://flyliufu.github.io/2017/03/25/算法学习总结1/","excerpt":"","text":"公用代码12345678910111213141516171819202122// 判断 v 是否小于 wpublic boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0;&#125;// i j 元素交换位置public void exch(Comparable[] a, int i, int j) &#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t;&#125;// 展示一个继承了Comparable 接口的数组public void show(Comparable[] a) &#123; for (Comparable anA : a) System.out.print(anA + \" \"); System.out.println();&#125;// 判断数组是否已经有序public boolean isSorted(Comparable[] a) &#123; for (int i = 1; i &lt; a.length; i++) &#123; if (less(a[i], a[i - 1])) return false; &#125; return true;&#125; ​ 以上几个方法贯穿所有关于排序算法总结。 选择排序JAVA实现代码123456789101112131415public void sort(Comparable[] a) &#123; int N = a.length; // 升序排列 for (int i = 0; i &lt; N; i++) &#123; //先假设数组中第一个元素是最小值 int min = i; // 将 a[i] 和 a[1,2,...N] 中最小的交换 for (int j = i + 1; j &lt; N; j++) &#123; // 如果发现 j 元素比 min 元素小将 min 下标重新赋值 if (less(a[j], a[min])) min = j; &#125; // 查找完所有元素后将 i 和最小元素交换位置 exch(a, i, min); &#125;&#125; 时间复杂度O(n2) 稳定性不稳定 总结​ 选择排序总是需要把无序的数组元素统统循环一遍后找到最小的一个数，将这个娄放到已经排好序的元素位置后面这样可能会做很多无用的比较，效率上不是最优的，实际应用场景也并不多。 插入排序JAVA实现代码12345678910public void sort(Comparable[] a) &#123; int N = a.length; for (int i = 1; i &lt; N; i++) &#123; // 如果 j 元素比 j - 1 元素小那么就交换元素位置 for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j--) &#123; // 交换元素位置 exch(a, j, j - 1); &#125; &#125;&#125; 时间复杂度O(n2) 稳定性稳定 总结​ 特别说明一下本算法对基本有序数组排序效果非常好 ​ 插入排序有人形象的比喻成玩扑克时候捋牌，当手上有一张牌时肯定是在第一位，抓到第二张时候需要和第一张比较一下如果大于位置不动，小于插入前面，再抓一张牌和第二张比较小于放前，大于位置不动，但这时候前面还有一张牌不确定是否比新抓的牌小所以还要比较一次小于放前，大于位置不动，这样可以保证三张牌是肯定有序的，依次类推直到牌全部抓完手中的牌也全部都是有序的。 希尔排序JAVA实现代码1234567891011121314151617181920public void sort(Comparable[] a) &#123; int N = a.length; int step = 3; int h = 1; while (h &lt; N / step) &#123; // 计算最大步长 h = step * h + 1; // 1,4,13,40,121,364,1093 ... &#125; // 判断步长是否为大于等于1 while (h &gt;= 1) &#123; // 遍历全部数组中的元素，起始值是步长例如 h = 13, i = 13 for (int i = h; i &lt; N; i++) &#123; // 判断相距 h 个元素的两个元素的大小情况，如果后者小于前者交换位置 for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123; exch(a, j, j - h); &#125; &#125; h /= step; &#125;&#125; 时间复杂度最好：O(nlog2n)、最坏：O(n2) 稳定性不稳定 总结​ 希尔排序是对插入排序的一次改进后者的优点就是在数组基本处于有序的时候排序效果很好，但乱序的时候并不理想，希尔排序改进了这点提出一个步长的设计思想，有这样一种可能就是长度 1000 的数组可能第1000个数最终的位置是在第一位这也是最糟糕的情况，单单排列这一个数就需要移动 999 次比较 999 次，这样实在是效率太低了，低于选择排序。 ​ 步长这个操作就很好解决了这个问题通过这个操作把最后一个元素移到第一位针对这个元素的比较、移动次数只是个位级别就完成了。以代码中的中长为例，一个长度 20 的数组排序步长分别是 1 、4、 13 开始比较是拿第1 个元素和第 14 元素比较 小于互换位置，大于位置不动，然后再用 2 和 15 元素比较最后是 7 和 20 ，假设第20是最小值，这时候他只比较一次就已经换到第 7 的位置了这和插入排序相比已经少做了很多次比较、交换，希尔排序的思路就是如此，大家可能注意到希尔排序最重要的是这个步长的设计，步长设计的好可以直接提高排序性能，的确是这样的，已知的最好步长序列是由Sedgewick提出的是由两个算式计算得出。","categories":[{"name":"原创","slug":"原创","permalink":"https://flyliufu.github.io/categories/原创/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://flyliufu.github.io/tags/JAVA/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://flyliufu.github.io/tags/Algorithms/"}]},{"title":"batchRemove方法分析","slug":"batchRemove方法分析","date":"2017-03-13T08:46:58.000Z","updated":"2017-03-13T14:58:04.000Z","comments":true,"path":"2017/03/13/batchRemove方法分析/","link":"","permalink":"https://flyliufu.github.io/2017/03/13/batchRemove方法分析/","excerpt":"","text":"​ batchRemove 这个方法是个 private 修饰只能在类内部用，主要用在了removeAll(Collection, Boolean)， retainAll(Collection, Boolean) 这两个方法中，根据第二个参数来决定是只删除集合中数据，还是只保留集合中的数据。 ​ 先说变量定义：这里定义一个final 的 Object 数组来接成员变量中的数组中的值（有什么意义啊？不太明白），还有两个 int 类型的变量 记录读r 和 写 w 还有个 boolean 值记录修改成功标志，try 块中只有一个 for 循环，它的作用是遍历当前数组，然后判断参数集合中是否包含当前的元素是否进 if 就要看参数传的是 true 还是 false 了，不管怎么样只要进了 if 里面后有个操作是把 同一个数组中 w 位置的元素覆盖成 r 位置的元素因为不管r 的是多少进if 块 w 肯定是从0开始的，这样就做到了只保留或只删除集合中的元素的功能（太牛逼了= =，我原来实现这个功能还是创建两个数组。。。）注意走完循环后 r ，w 的值肯定是小于或等于 size 的， ​ 为了方便先模拟一个环境 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyArrayList &#123; private int modCount = 0; private int size = 6; private Object[] elementData = &#123; 1, 2, 3, 4, 5, 6 &#125;; public boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) &#123; elementData[w++] = elementData[r]; &#125; System.out.println(String.format(\"r value is %d, r value is %d\", r, w)); &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125;&#125; ​ 里面的数据是写死的这不重要。 123456789public static void main(String[] args) &#123; MyArrayList array = new MyArrayList(); ArrayList&lt;Integer&gt; collection = new ArrayList&lt;&gt;(); collection.add(1); collection.add(2); collection.add(3); array.retainAll(collection);&#125;// 输出： r value is 6, w value is 3 ​ 大概可以理解为 retainAll() 一共做了六次读取操作，其中有三次读取同时做了写入操作。最后数组中也只保留了两个数组的相同的部分，同理 removeAll() 最后结果是只删除了两个集合相同的部分有一点说明一下，在 batchRemove() 处理完数据后有一步操作是把数组中多余出来的空间置空的操作 123456123nullnullnull ​ retainAll() 操作结束后原来有六个空间，只剩下了3个元素空下来3个空间被置为了 null 等待 GC 回收操作，但这时候我们也可以手动去释放这些空间，还记得之前说到一个方法 trimToSize() 在这用到了，调用一下这个方法，释放一些本来就不多的手机内存吧。（这个方法我也只明白了一部分，在 finally 块中的代码有些不太理解，希望有兴趣的同学一起来讨论下~~）","categories":[{"name":"原创","slug":"原创","permalink":"https://flyliufu.github.io/categories/原创/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://flyliufu.github.io/tags/JAVA/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://flyliufu.github.io/tags/ArrayList/"}]},{"title":"JAVA源码学习之ArrayList(3)","slug":"JAVA源码学习之ArrayList-3","date":"2017-03-12T14:08:01.000Z","updated":"2017-03-17T07:49:24.000Z","comments":true,"path":"2017/03/12/JAVA源码学习之ArrayList-3/","link":"","permalink":"https://flyliufu.github.io/2017/03/12/JAVA源码学习之ArrayList-3/","excerpt":"","text":"retainAll &amp; removeAll12345678public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true);&#125;public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false);&#125; ​ 这两个方法是一对没什么可讲的主要是子方法 batchRemove 有些难懂我放在了另一个博客中分析，希望有想法的朋友可以一起讨论。 add1234567891011public void add(int index, E element) &#123; // 检查 index 的数值是否合法 rangeCheckForAdd(index); // 保证容量有位置可以放下接下来的一个元素 ensureCapacityInternal(size + 1); // Increments modCount!! // (1) System.arraycopy(elementData, index, elementData, index + 1, size - index); // (2) elementData[index] = element; size++;&#125; ​ (1) 在确保有了足够的位置后调用 System.arraycopy 方法把 index 位置的元素整体向后移一位，这样就把 index 位置的数据空出来了。 ​ (2) 把传入的参数覆盖原来的数据这样就实现了在固定位添加元素功能，最后把 size 自增。 remove1234567891011121314151617public E remove(int index) &#123; rangeCheck(index); modCount++; // 保存下将要删除元素 E oldValue = elementData(index); // 计算需要移动的元素个数 int numMoved = size - index - 1; // 如果需要移动个数大于0，有可能等于0， 但不会小于0 if (numMoved &gt; 0) &#123; // (3) System.arraycopy(elementData, index + 1, elementData, index, numMoved); &#125; // 把最后一个元素置空 elementData[--size] = null; // clear to let GC do its work // 返回已经删除的元素 return oldValue;&#125; ​ (3) 这句话就是说把从 index + 1 开始 numMoved 个元素重新放入 elementData 中 从 index 位置开始中。 12345678910111213141516171819202122232425262728public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; // 如果为空遍历数组把第一个为空的元素移除返回 true fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; // 不为空时候查找到和对象相等的情况下再移除，返回 true fastRemove(index); return true; &#125; &#125; return false;&#125;// 私有删除方法，不检查下标界限并且不返回删除元素private void fastRemove(int index) &#123; // 该方法大致和 remove 相同只是为了速度不去做校验，不返回 modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, numMoved); &#125; elementData[--size] = null; // clear to let GC do its work&#125; addAll1234567891011121314public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 转换成数组 Object[] a = c.toArray(); // 获得添加数组的长度 int numNew = a.length; // 确定有足够的空间存放数据 ensureCapacityInternal(size + numNew); // Increments modCount // 在当前数组后面追加 numNew 个元素 System.arraycopy(a, 0, elementData, size, numNew); // 更新当前数组的 size 个数 size += numNew; // 如果参数数组长度不为0 返回true return numNew != 0;&#125; 123456789101112131415161718public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount // 结果是大于等于0的一个值，如果是等于0 就是在末尾追加 int numMoved = size - index; if (numMoved &gt; 0) &#123; // 这块的逻辑同 add 只是 add 是移动了一个位置， // 而这需要移动 index + numNew 个元素来存放参数数组中的元素 System.arraycopy(elementData, index, elementData, index + numNew, numMoved); &#125; // 把 a 中的 numNew 个元素追加到 elementData 中 index 开始里面 System.arraycopy(a, 0, elementData, index, numNew); // 更新 size 长度 size += numNew; return numNew != 0;&#125; removeRange12345678910111213141516// 移除一段区域中的数据 protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; // 计算需要移动数据个数 int numMoved = size - toIndex; // 将 elementData toIndex 开始的数据覆盖成 elementData 从 fromIndex 开始 到结束 numMoved 个元素 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work //计算下新数组的长度 int newSize = size - (toIndex - fromIndex); // 把没有用到的空间元素置空，可以让GC working for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; //重新定义长度&#125;","categories":[{"name":"原创","slug":"原创","permalink":"https://flyliufu.github.io/categories/原创/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://flyliufu.github.io/tags/JAVA/"},{"name":"Array","slug":"Array","permalink":"https://flyliufu.github.io/tags/Array/"},{"name":"Android","slug":"Android","permalink":"https://flyliufu.github.io/tags/Android/"}]},{"title":"copyOf相关方法总结","slug":"copyOf相关方法总结","date":"2017-03-10T07:23:46.000Z","updated":"2017-03-13T08:47:48.000Z","comments":true,"path":"2017/03/10/copyOf相关方法总结/","link":"","permalink":"https://flyliufu.github.io/2017/03/10/copyOf相关方法总结/","excerpt":"","text":"copyOf​ 在学习 ArrayList 时候遇到很多地方全用到了 Arrays.copyOf() 方法，搞不清楚这个方法感觉学习 ArrayList 会遇到一些阅读困难啊，所以专门写个关于这个方法及相关方法的学习贴吧。 ​ copyOf() 及其相关方法如此之多光这一个方法就有五六个重载方法但万变不离其宗其实重载方法的含义是一样，这只把几个特殊的方法拿出来研究一下 123public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125; ​ 这个方法没什么可说的主要就是调用了一下本类中的另一个方法然后强转下泛型T[] ，接下来看下这个关键的引用 方法是怎么个实现方法。 12345678public static &lt;T, U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(\"unchecked\") T[] copy = ((Object) newType == (Object) Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; ​ 这个方法牛逼大了啊，泛型还是两个首先来解释下参数第一个是原始数组参数，第二个参数是新数组的长度，第三个参数是生成后新数组类的类型这个类型必须是个数组类型像 String[].getClass()，Integer[].getClass()，Number[].getClass()，等都可以，但不可以是String.getClass()这种类型好吧，很容易理解。方法代码部分第一句话有点长用了一个三目运算符条件是参数类型是否是Object[] 类型 如果是就直接实例化出一个Object[] 数组长为 newLength ，如果不是。。。就创建出一个数组，Class.getComponentType() 该方法只有当参数是个数组的时候才返回值如果不是数组只返回 null ，不懂就自己写个例子看看。 ​ 上一步最终会创建出一个数组，然后调用 System.arraycopy([],int,[],int,int) 这个方法没什么可说的，主要是最后一个参数是告诉方法复制的数组长度是多少，最后返回创建的数组这个方法叫 copyOf 但看方法实现更像是 newAndCopyOf 我是这么理解的有更好的请指点一二谢谢。 12345public static byte[] copyOf(byte[] original, int newLength) &#123; byte[] copy = new byte[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; ​ 还有很多这种重载方法，但除了类型不一样其他的都是一样的只看一个就可以了，而且这个方法好像也不难。","categories":[{"name":"原创","slug":"原创","permalink":"https://flyliufu.github.io/categories/原创/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://flyliufu.github.io/tags/JAVA/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://flyliufu.github.io/tags/ArrayList/"}]},{"title":"ArrayList方法clone探究","slug":"ArrayList方法clone探究","date":"2017-03-08T14:39:37.000Z","updated":"2017-03-13T08:48:03.000Z","comments":true,"path":"2017/03/08/ArrayList方法clone探究/","link":"","permalink":"https://flyliufu.github.io/2017/03/08/ArrayList方法clone探究/","excerpt":"","text":"123456789public class Test &#123; // 源数组 static ArrayList&lt;Bean&gt; beans = new ArrayList&lt;&gt;(); // 目标数组 static ArrayList&lt;Bean&gt; copyBeans = new ArrayList&lt;&gt;();&#125;class Bean &#123; public int i;&#125; ​ 期望是将 beans 中的数据复制到 copyBeans 集合中。 12345public static void init()&#123; for (int i = 0; i &lt; 10; i++) &#123; beans.add(new Bean(i)); &#125;&#125; ​ ·init()方法中我循环创建了10 个对象添加到beans 集合中备用。 1234public static void main(String[] args) &#123; init(); copyBeans = (ArrayList&lt;Bean&gt;) beans.clone();&#125; ​ 初始化集合，然后 copy 集合数据赋值给另一个ArrayList 对象实例。 123456789System.out.println(beans == copyBeans); //falsefor (int i = 0; i &lt; beans.size(); i++) &#123; System.out.println(beans.get(i).equals(copyBeans.get(i))); // true&#125;for (int i = 0; i &lt; beans.size(); i++) &#123; System.out.println(beans.get(i) == copyBeans.get(i)); // true&#125; ​ 来看下这几行代码运行结果第一个是false 可以理解是经过 clone() 确实是克隆了一份给了copyBeans，接下来这个也不难懂equals(Object) 这里的equals() 用的是Object 类中的方法，而Object 中这个方法实现实际 就是用 == 来判断和下面这个判断方法其实是一样的，那么在 Java 中对象如果相等证明他们所用的内存是一样的，那是不是这样的用代码来说话（具体这个 equals() 方法介绍请看这里 ）。 1234for (int i = 0; i &lt; beans.size(); i++) &#123; beans.get(i).i = i + 3; System.out.println(copyBeans.get(i).i);&#125; ​ 我给源数组 beans 循环加 3 然后把同位置目标数组中的值打印输出结果所示: 123456789103456789101112 ​ 也就充值证明了 clone() 后只是开辟了一个空间引用，其真正所指向的还是原来数组的内存空间只要任意一个数组有改变操作另一个也会受到影响这也就是官方注释上说的 Shallow copy。 ​ 虽然这个搞明白了但工作中有的时候确实有这个需要clone() 出一个新的数组做操作但又不影响源数组的数据该怎么办呢？我也是个菜鸟目前我能想到的办法也很低级如果拉低了读到博客的人的智商表示抱歉。。。 ​ 首先在 Bean 类中增加一个构造函数，参数是本类，然后把参数中的值对应的赋到对应的属性中 123public Bean(Bean bean) &#123; this.i = bean.i;&#125; ​ 创建克隆方法： 1234567static ArrayList&lt;Bean&gt; myClone(ArrayList&lt;Bean&gt; beans) &#123; ArrayList&lt;Bean&gt; localBeans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; beans.size(); i++) &#123; localBeans.add(new Bean(beans.get(i))); &#125; return localBeans;&#125; ​ 替换原来的克隆方法改为自定义的： 12// copyBeans = (ArrayList&lt;Bean&gt;) beans.clone();copyBeans = myClone(beans); ​ 剩下的不变再把代码运行一次会发现： 12345678910111213141516171819202122232425262728293031falsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalse0123456789 ​ 哈两个数组完全不会互相干扰了，想怎么改不会影响对方了~~","categories":[{"name":"原创","slug":"原创","permalink":"https://flyliufu.github.io/categories/原创/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://flyliufu.github.io/tags/JAVA/"},{"name":"Array","slug":"Array","permalink":"https://flyliufu.github.io/tags/Array/"}]},{"title":"JAVA源码学习之ArrayList(2)","slug":"JAVA源码学习之ArrayList-2","date":"2017-03-08T13:17:13.000Z","updated":"2017-03-11T13:32:19.000Z","comments":true,"path":"2017/03/08/JAVA源码学习之ArrayList-2/","link":"","permalink":"https://flyliufu.github.io/2017/03/08/JAVA源码学习之ArrayList-2/","excerpt":"","text":"​ 继续上篇博客学习1234567891011121314151617181920212223242526272829public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i] == null) &#123; return i; &#125; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) &#123; return i; &#125; &#125; return -1;&#125;public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size - 1; i &gt;= 0; i--) if (elementData[i] == null) &#123; return i; &#125; &#125; else &#123; for (int i = size - 1; i &gt;= 0; i--) if (o.equals(elementData[i])) &#123; return i; &#125; &#125; return -1;&#125; ​ 名称上来看是用来查找一个元素是否存在数组中，如果找不到返回 -1 ，当查找的元素为 null 时候遍历数组中的元素把第一个为 null 的元素下标返回，如果不为空依旧是遍历数组后找到对象和元素值对应第一个的下标返回，下面是查找最后一个和对象相等元素的下标基本和上一个方法原理一样，只是这个方法是从后往前遍历而已。 1234567891011121314151617/** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125;&#125; ​ clone() 虽说没几行代码但还确实有点难懂，也许需要个例子来辅助来理解这个方法了。 12345678910111213@SuppressWarnings(\"unchecked\")public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: &#123; return (T[]) Arrays.copyOf(elementData, size, a.getClass()); &#125; System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) &#123; a[size] = null; &#125; return a;&#125; ​ toArray(T[]) 看到这个方法很是懵啊，ArrayList&lt;E&gt; 声明时候是用的 E 这个方法怎么是用的 T 很是不理解这种设计的思路上网查了些资料后明白了一些原由，不管当初是为啥这样设计反正已经这样了用的时候加小心就成了，代码的意思主要难在第一个if 块了，判断T[] 的长度和当前集合长度谁大，如果传入数组长度小就执行if 里面，123E elementData(int index) &#123; return (E) elementData[index];&#125; ​ 返回数组中下标为 index 的元素，这个方法没有对 index 校验，所以 Java 也没把他设置成可外部访问的方法。 12345678private void rangeCheck(int index) &#123; if (index &gt;= size) &#123; throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125;&#125;private String outOfBoundsMsg(int index) &#123; return \"Index: \" + index + \", Size: \" + size;&#125; ​ 只是内部公用的用来公共检查index 是否合法会抛出运行时异常 IndexOutOfBoundsException，另一个方法只是返回一个字符串告诉下标和size 的值。 1234public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; ​ ArrayList 是常用的方法之一，get(int) 其实现很简单，先是校验 index 的合法性，之后调用查找元素的方法把对应元素返回。 123456public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; ​ 该方法也很容易功能就是把指定下标的元素替换为新元素，并返回被替换掉的元素。 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; ​ 这个方法很简单但功能确是很重要，调用方法确定下当前 elementData 数组中确实还有位置可以放下新的元素，这个方法之前学习过不再多说了，确定完容量后把当前这个赋值给数组然后数组长度加一。 123456789101112131415public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) &#123; throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125;&#125; ​ 这是 add 的另一个重载方法","categories":[{"name":"原创","slug":"原创","permalink":"https://flyliufu.github.io/categories/原创/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://flyliufu.github.io/tags/JAVA/"},{"name":"Array","slug":"Array","permalink":"https://flyliufu.github.io/tags/Array/"},{"name":"Android","slug":"Android","permalink":"https://flyliufu.github.io/tags/Android/"}]},{"title":"JAVA源码学习之ArrayList (1)","slug":"JAVA源码学习之ArrayList","date":"2017-03-07T07:42:52.000Z","updated":"2019-08-12T06:55:47.272Z","comments":true,"path":"2017/03/07/JAVA源码学习之ArrayList/","link":"","permalink":"https://flyliufu.github.io/2017/03/07/JAVA源码学习之ArrayList/","excerpt":"","text":"ArrayList先从他的构造函数开始看起：1234567public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) &#123; throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity); &#125;s this.elementData = new Object[initialCapacity];&#125; ​ 该构造函数接受一个int参数作为该ArrayList 的初始化大小，如果这个值小于0会抛出一个IllegalArgumentException（非法参数）异常，应该没有人这 么二想创建一个长度为-2的集合吧… 如果参数合法就会实例化一个Object 类型的数组大小为参数的值。 12345private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA;&#125; 无参的没什么可说的。 1transient Object[] elementData; // non-private to simplify nested class access 这个变量单独说一下： ​ transient 是不想被序列化，默认的变量修饰符为了非私有简化嵌套类访问说白了应该就是为了可以访问到这个变量但又不想用 public 、protected修饰访问权限过大。 12345678public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) &#123; elementData = Arrays.copyOf(elementData, size, Object[].class); &#125;&#125; ​ 这个构造函数是可以接收一个Collection（集合）类型的参数构造出一个 Object数据集，参数是个泛型这个很好理解(我这么笨都可以理解应该不难)，第二行就是调用Collection 的方法把其对象转换成一个数组类型对象，第三行就是获取个长度调用方法size()时候用，读到这看到一行注释大意说的是Collection.toArray()这个方法的返回有可能并不是一个 Object[] 具体为啥请参照这篇博客 说的也很明白了，下面就是判断如果确实toArray()方法得到的并不是一个Object[] 那就用工具方法Arrays.copyOf()重新给这个数组赋值，就是说elementData 这个数组不管由那个构造函数创建出来的，一定要是个Object[]。 123456public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = Arrays.copyOf(elementData, size); &#125;&#125; ​ 这个方法作用是却除 ArrayList 中多申请出来的内存空间具体为什么会多出空间下面会说到。 ​ 接下来的几个方法可能分比较重要了即使不重要那怎么可能，不重要写他做什么这里面的每个方法都很重要吧！但这几个方法是有关联的先从最底层的方法grow() 这个方法说起吧。 12345678910111213141516171819202122232425262728293031323334353637/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) &#123; newCapacity = minCapacity; &#125; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; newCapacity = hugeCapacity(minCapacity); &#125; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow &#123; throw new OutOfMemoryError(); &#125; return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; ​ 这个方法比较重要我把官方注释也放进来了如有翻译不当也不要说我误人子弟，官方解释在这请自己看~，先说说这个常量MAX_ARRAY_SIZE 它从字面意思上来理解就是ArrayList 的最大元素个数，其实值是Integer 最大值减8官方说不直接用最大值的原因是有些 VM 会在ArrayList中保留一些头数据，如果用最大值会 OOM至于为什么是8 不是别的数我不知道，有知道的也希望告诉我哦~~， ​ 进入正题~ grow(int) 方法这个方法作用就是在 ArrayList 空间可能不足以放下（只是计算机认为的可能）接下来的数据的时候对elementData 这个数组进行扩充(方法叫 grow 有生长的意思，怎么翻译都成谁让笔记是我写的)，方法代码第一行获取当前数组长度用临时变量保存，接下来会用到，既然是扩充那扩充多少合适要有个规定不能随机一个数来扩充是吧。这里采用的方式用了一个很妙的算术运算来得出的首先当然要保证不会比扩充前数组长度小基数肯定是老数组的长度oldCapacity ，加上一个数 oldCapacity &gt;&gt; 1 这就是妙的地方他用了个位运算，细节我不讲了位运算不懂还当什么程序员。。。得出来的新值大约是老数组长度的1.5倍（是约等于哦~~），接下来有个判断是拿申请空间大小来和扩充后的值对比，谁大要谁的值没什么好说的，再下来是用新长度减去数组最大长度如果为正数这里又调用了一个方法hugeCapacity(int) 下面也贴出来了方法代码：这个方法做的操作比较简单如果入参数小于0 直接出异常没商量，如果没事往下判断申请扩充空间大小和数组最大值谁大，如果是申请值大那就把整数最大值给他，反之就是数组最大值了然后返回一个值，跳出hugeCapacity(int)，这时候newCapacity已经计算好了一个相对合理的值，然后调用方法把原来数组中的数据 copy 根据新容量生成一个新的数组赋值给elementData 这个数组（用了很多Arrays.copyOf(Object[], int) 这个方法看来回头要看下怎么实现的了）。","categories":[{"name":"原创","slug":"原创","permalink":"https://flyliufu.github.io/categories/原创/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://flyliufu.github.io/tags/JAVA/"},{"name":"Array","slug":"Array","permalink":"https://flyliufu.github.io/tags/Array/"},{"name":"Android","slug":"Android","permalink":"https://flyliufu.github.io/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-02T01:28:53.000Z","updated":"2017-03-08T13:28:13.000Z","comments":true,"path":"2017/03/02/hello-world/","link":"","permalink":"https://flyliufu.github.io/2017/03/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://flyliufu.github.io/tags/JAVA/"}]}]}